## not to be run directly. use main.py

import pdb
import re
import sys
import getopt
import shutil
import os
import math
import argparse
import pickle as pickle
import bz2
from functools import wraps
from collections import defaultdict
from abc import ABC, abstractmethod
import io
from urllib.parse import urlparse
import json

import common
import log_processor

#############################################

from classes import *

#################################

g_log_processor = log_processor.LogProcessor()

#################################
#################################
###   global state

g_known_resources = {} # some resources are created but not fetched
g_fetched_instNum_to_resource = {}

# resources that we see being fetched by io system (e.g.,
# http_network_transaction/stream_parser) but we don't know about in
# webkit land. this can happen, for example, with favicon resources
#
# for these resources, since their resource instnums are zeros, we
# will use the netlog id ("nlid") instead as the map key
g_unknown_resource_fetches = {}

g_main_resource = None
g_main_doc = None
g_body_element = None
g_html_element = None

# # there can only be ONE parser blocking script at a time
# g_parserBlockingScript = None

g_webkit_log_events = []

g_dns_prefetches = set() # of link elements

# g_elements = {}

# multiple "Resources" can use the same url, e.g., an OPTIONS request
# and GET request and a POST can all use the same url, but can/will
# have its own Resource object created by ResourceFetcher
#
# map from url to... a map from resInstNum to Resource object
g_fetched_url_to_resources = defaultdict(dict)

# multiple elements (e.g., images) can refer to the same url. for
# purposes of generating network requests, only the first element (the
# one appearing earliest in html) matters, so we will ignore later
# ones. UNLESS one element is generated by a script while the other is
# part of static html that appears after the script element, then the
# background parser/preload scanner comes into play and there exists a
# race, so we will have to know about both elements.
#
# map from "completeURL" to set

g_url_to_elements = defaultdict(set)

# ## multiple xhr can request the same url
# g_url_to_xhrs = defaultdict(dict)

# map from a resource instNum that starts fetching during the creation
# of an xhr loader
g_resInstNum_to_xhr = {}

g_current_num_blocking_sheets = 0


# map from event target instance num to event target. event targets
# include dom windows, nodes, elements, documents, etc.
g_instNum_to_event_target = {}


g_xhrs = {}

# map from timerID to DOMTimer objs ...  in webkit , it seems
# timerID's are unique per document/execution context, so we can have
# a timerID:1 for doc:7 and a timerID:1 for doc:1201, etc.
#
# so, we use this scheme for OUR timerID: docInstNum*10000 + timerID

g_domTimers = {}

def compute_timerID(docInstNum, timerID):
    assert timerID < 10000
    return (docInstNum*10000) + timerID

def get_domTimer(docInstNum, timerID):
    return g_domTimers.get(compute_timerID(docInstNum, timerID), None)

def add_domTimer(docInstNum, timerID, timer):
    _id = compute_timerID(docInstNum, timerID)
    assert _id not in g_domTimers
    g_domTimers[_id] = timer
    pass


g_scheduled_render_tree_update = None

g_scheduled_execution_of_scripts_blocked_by_style_resources = None

g_scheduled_font_loader_timer = None

# render tree updates can take significant time, so we want to know
# about them even if they do not generate network requests
g_render_tree_update_scopes = []

g_load_pending_fonts_timer_scopes = []

# v8 scopes can also take significant time, so we also want to know
# about them even if they do not generate network requests
g_v8_scopes = []

def add_v8_scope(scope):
    if len(g_v8_scopes) > 0:
        # v8 scopes CAN overlap
        pass

    g_v8_scopes.append(scope)
    pass

# stack of currently open scopes (can be of different kinds)
g_scope_stack = []

# scopes that have no outer scope
g_top_level_scopes = []


g_all_fetch_requests = []

# promise inst num -> classes.Promise obj
g_promises = {}

g_promise_microtasks = {}

g_script_runner = HTMLScriptRunner()

g_html_doc_parsers = {}

# g_dom_microtasks = {}


# keep track of the iframes, which we don't handle yet. this is set of
# urls
g_unhandled_iframes = set()

#################################

class _MinimalDummyScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

def add_font_loader_timer_scope(scope):
    assert type(scope) == LoadPendingFontsTimerFiredScope
    g_load_pending_fonts_timer_scopes.append(scope)
    pass

def add_render_tree_update_scope(scope):
    assert type(scope) == RenderTreeUpdateScope

    global g_scheduled_render_tree_update

    if g_render_tree_update_scopes:
        # make sure they do not overlap
        prev_scope = g_render_tree_update_scopes[-1]
        assert prev_scope.has_closed()
        # use "<=" because sometimes render update scopes can happen
        # back-to-back
        assert prev_scope.close_ts() <= scope.open_ts(), '{} {}'.format(prev_scope.close_ts(), scope.open_ts())

        # it's possible to see a render update without a schedule,
        # e.g., after a <body> element is removed/inserted. maybe the
        # update is just forced?

        # # make sure there is a ScheduledRenderTreeUpdate?
        # assert g_scheduled_render_tree_update is not None
        pass
    else:
        scope.set_is_initial()
        pass

    # the first render tree update doesnt seem be scheduled; it might
    # be that the first render is not scheduled at all
    if g_scheduled_render_tree_update:
        g_scheduled_render_tree_update.set_dst(scope)

        the_scheduler = g_scheduled_render_tree_update.src()
        if isinstance(the_scheduler, ExecutionScope):
            if not the_scheduler.has_closed():
                # if the render update is an inner scope of the one
                # that schedules the update, then for simplicity, we
                # can just get rid of the scope
                g_scheduled_render_tree_update.drop()
                scope = None
                pass
            pass
        elif the_scheduler is None:
            # if scope is short and doesn't have any interesting out
            # edges we can skip it
            # assert scope.duration() < 5.0
            # assert not scope.out_edges(includeInnerScopes=True)
            # scope = None
            pass
        else:
            assert type(the_scheduler) is ShadowHostElement, str(the_scheduler)
            pass
        pass

    if scope is not None:
        g_render_tree_update_scopes.append(scope)
        pass

    g_scheduled_render_tree_update = None
    pass

def push_scope(scope):
    if len(g_scope_stack) == 0:
        g_top_level_scopes.append(scope)
        pass
    g_scope_stack.append(scope)
    logging.debug('++++ scope "{}" pushed, new stack size {}'.format(str(scope), len(g_scope_stack)))
    pass

def find_outer_scope(scopeClassOrClasses):
    # find the first outer scope whose class is scopeClass. we search
    # from the inner most scope towards to outermost/root scope
    for scope in reversed(g_scope_stack):
        if isinstance(scope, scopeClassOrClasses):
            return scope
        pass

    return None

def pop_scope():
    scope = g_scope_stack.pop()
    logging.debug('---- scope "{}" popped, new stack size {}'.format(str(scope), len(g_scope_stack)))
    return scope

# get the outer scope at level (>= 0) above current scope, e.g.,
# level=0 returns inner most scope
def outer_scope_at(level):
    assert level >= 0 and level < len(g_scope_stack)
    return g_scope_stack[-1 - level]

# get the inner-most important scope
def current_important_scope():
    for scope in reversed(g_scope_stack):
        if scope.is_important():
            return scope
        pass
    return None

def scope_stack_size():
    return len(g_scope_stack)

# return true if we currently executing javascript; it could be
# running a script element, handling some event, running some
# microtask, etc.
def is_executing_javascript():
    return find_outer_scope((V8Scope,
                             _PerformMicrotaskCheckpointScope,
                             EventTargetInvokingListenersScope))


def _ignore_promiseInstNums(promiseInstNumOrNums):
    # some pages, e.g., berkeley.edu creates a lot of promises, making
    # the visualized graph messy with many edges among the
    # promises. this function is just a hacky way to not process some
    # promises, just for testing/eye-balling purposes

    # if type(promiseInstNumOrNums) is int:
    #     return promiseInstNumOrNums >= 10
    # else:
    #     return any(map(lambda instNum: instNum >= 10, promiseInstNumOrNums))
    return False

#################################
#################################

def print_scope_tree(scopes, left_margin=4):
    if len(scopes) == 1:
        logging.info((' '*left_margin) + scopes[0].toString())
        return
    for i, scope in enumerate(scopes):
        scopeAsString = scope.toString(succinct=False)
        if i < (len(scopes) - 1):
            logging.info((' '*left_margin) + '|' + (i*4*' ') + scopeAsString)
            pass
        else:
            logging.info((' '*left_margin) + ('+' + ((i*4)-2)*'-') + '> ' + scopeAsString)
            pass
        pass
    return


def _get_bool_from_int(v):
    assert type(v) == int and v in (0, 1)
    return v == 1

def _validate_instNum(instNum):
    assert type(instNum) == int and instNum >= 1
    return

def _validate_instNum_decorator(func):
    @wraps(func)
    def func_wrapper(instNum):
        _validate_instNum(instNum)
        return func(instNum)
    return func_wrapper

@_validate_instNum_decorator
def _check_resInstNum(resInstNum):
    assert resInstNum in g_known_resources, \
      'res:{} is not yet known'.format(resInstNum)
    return

@_validate_instNum_decorator
def _check_event_target_instNum(instNum):
    if not instNum in g_instNum_to_event_target:
        raise KeyError('et:{} is not yet known'.format(instNum))
    return

# make sure the prefix info is as expected
def _check_log_event_info(fileName=None, lineNumber=None,
                          functionName=None, functionNames=[]):
    # either one functionname or list of functionnames; don't do both
    assert (not functionName) or (not functionNames)
    def decorator(func):
        @wraps(func)
        def func_wrapper(log_event_info, *args, **kwargs):
            try:
                # common.dlog('event info: {event_info}'.format(event_info=log_event_info))
                assert fileName is None or log_event_info.fileName == fileName, \
                  'expect "{expect}", got "{got}"'.format(
                      got=log_event_info.fileName, expect=fileName)
                assert lineNumber is None or log_event_info.lineNumber == lineNumber, \
                  'expect {expect}, got {got}'.format(
                      got=log_event_info.lineNumber, expect=lineNumber)
                assert functionName is None or log_event_info.functionName == functionName, \
                  'expect "{expect}", got "{got}"'.format(
                      got=log_event_info.functionName, expect=functionName)
                if functionNames:
                    assert log_event_info.functionName in functionNames, \
                      'expect one of {expect}, got \'{got}\''.format(
                          got=log_event_info.functionName, expect=functionNames)
                    pass
                return func(log_event_info, *args, **kwargs)
            except Exception as e:
                raise Exception('function {} throws error: {}'.format(func.__name__, e))
            raise Exception('not reached')
        return func_wrapper
    return decorator

def _check_pushed_scope_has_scopeStart(func):
    @wraps(func)
    def func_wrapper(*args, **kwargs):
        try:
            _global_num_scopes_before = len(g_scope_stack)
            retval = func(*args, **kwargs)
            _global_num_scopes_after = len(g_scope_stack)
            if _global_num_scopes_after > _global_num_scopes_before:
                assert (_global_num_scopes_before + 1) == _global_num_scopes_after
                assert outer_scope_at(0).scopeStart() is not None, \
                  'pushed a scope without scopeStart'
                pass
            return retval
        except Exception as e:
            raise Exception('function {} throws error: {}'.format(func.__name__, e))
        raise Exception('not reached')
    return func_wrapper


########

_res_type_str_to_enum = {
    "MainResource": ResourceType.MainResource,
    "Image": ResourceType.Image,
    "CSSStyleSheet": ResourceType.CSSStyleSheet,
    "Script": ResourceType.Script,
    "Font": ResourceType.Font,
    "Raw": ResourceType.Raw,

    # for now we don't support the following types; will add once they
    # are encountered

    # "SVGDocument",
    # "XSLStyleSheet",
    # "LinkPrefetch",
    # "LinkSubresource",
    # "TextTrack",
    # "ImportResource",
    # "Media",
    }


_scope_action_pattern_str = r'(?P<action>[^ ]*)( \(dur= [\d.]+\))?'

_window_pattern_str = r'window:(?P<windowInstNum>.*)'

_elem_pattern_str = r'elem:(?P<elemInstNum>\d+)'

_doc_pattern_str = 'doc:(?P<docInstNum>\d+)'

_fontfaceset_pattern_str = 'fontfaceset:(?P<fontfacesetInstNum>\d+)'

_my_js_log_pattern_str = 'my js log \[(?P<who>.*)\]'

_promise_pattern_str = 'promise:(?P<promiseInstNum>.*)'
_promise2_pattern_str = 'promise:(?P<promiseInstNum2>.*)'

_fetcher_pattern_str = 'fetcher:(?P<fetcherInstNum>\d+)'

_xhr_pattern_str = 'xmlhttprequest:(?P<xhrInstNum>\d+)'

_event_target_pattern_str = 'eventtarget:(?P<eventTargetInstNum>\d+)'

_parser_pattern_str = 'parser:(?P<parserInstNum>\d+)'

_res_pattern_str = r'res:(?P<resInstNum>\d+)'

_netlog_id_pattern_str = r'nlid:(?P<nlid>\d+)'

_not_shown_url = '<not shown>'

_domtimer_pattern_str = 'timerID:(?P<timerID>\d+)'

_dommicrotask_pattern_str = 'dommicrotask:(?P<taskInstNum>\d+)'

_scheduledAction_pattern_str = 'scheduledAction:(?P<scheduledActionInstNum>\d+)'

_scopeStart_pattern_str = 'scopeStart:(?P<scopeStart>.*)'

_promise_microtaskID_pattern_str = 'taskID:(?P<taskID>\d+)'

# t=1, ts=    181.91, Resource.cpp :137, Resource(): ___ res:3, url [...], type= [CSSStyleSheet], isDataURL= 0, created

@g_log_processor.register(
    r'^' + _res_pattern_str + r', url \[(?P<url>.+)\], '
    'type= \[(?P<type>.*)\], isDataURL= (?P<isDataURL>[\d+]), created$')
@_check_log_event_info(fileName='Resource.cpp', functionName='Resource()')
def _handle_wk_res_created(log_event_info,
                           resInstNum, url, type, isDataURL):
    resInstNum, isDataURL = list(map(int, (resInstNum, isDataURL)))
    isDataURL = _get_bool_from_int(isDataURL)
    assert url != _not_shown_url or isDataURL

    type = _res_type_str_to_enum[type]

    assert resInstNum not in g_known_resources, \
      'res:{resInstNum} created twice! at {first} and {second}'.format(
          resInstNum=resInstNum, first=g_known_resources[resInstNum],
          second=log_event_info.ts)

    resourceClass = Resource
    if type == ResourceType.CSSStyleSheet:
        resourceClass = StyleSheetResource
        pass
    elif type == ResourceType.Script:
        resourceclass = ScriptResource
        pass

    resource = resourceClass(
        instNum=resInstNum, url=url, type_=type, isDataURL=isDataURL,
        create_ts=log_event_info.ts, creator_scope=current_important_scope())
    g_known_resources[resInstNum] = resource

    if resInstNum == 1 or type == ResourceType.MainResource:
        if type == ResourceType.MainResource and resInstNum != 1:
            # must be a frame that we don't handle yet
            # assert url == 'about:blank' or url in g_unhandled_iframes
            pass
        else:
            assert resInstNum == 1 and type == ResourceType.MainResource
            global g_main_resource
            assert g_main_resource is None
            g_main_resource = resource
            pass
        pass
    return

# t=1, ts=    864.98, ResourceLoader.cpp :430, didFinishLoading(): ___ scopeStart:1465228019281.244141: doc:7: res:5: begin
# t=1, ts=    865.19, ResourceLoader.cpp :430, didFinishLoading(): ___ scopeStart:1465228019281.244141: doc:7: res:5: done (dur= 0.212158)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _res_pattern_str + ': ' + _scope_action_pattern_str + '$',
    fileName='ResourceLoader.cpp', functionName='didFinishLoading()')
@_check_log_event_info(fileName='ResourceLoader.cpp', functionName='didFinishLoading()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_res_finish_loading(log_event_info,
                                  scopeStart, docInstNum, action, resInstNum):
    resInstNum = int(resInstNum)
    _check_resInstNum(resInstNum)
    assert resInstNum in g_fetched_instNum_to_resource
    resource = g_fetched_instNum_to_resource[resInstNum]
    assert resource.instNum == resInstNum
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = FetchFinishScope

    if action == 'begin':
        # fetch finish should be a top-level scope
        assert not scope_stack_size()
        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart,
                           resInstNum=resInstNum)
        push_scope(scope)
        if resource != g_main_resource:
            resource.finishes_fetching(ts, scope)
            pass
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.resInstNum == resInstNum
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return


# t=1, ts=    845.91, Document.cpp :1343, setReadyState(): ___ scopeStart:1465228019262.177979: doc:7: dispatch event [readystatechange], state [loading]: begin
# t=1, ts=    845.95, Document.cpp :1343, setReadyState(): ___ scopeStart:1465228019262.177979: doc:7: dispatch event [readystatechange], state [loading]: done (dur= 0.035889)

_docReadyStates = set(['loading', 'interactive', 'complete'])

# class _DOMReadyStateChangeEventScope(EventTargetEventScopeBase, UnimportantExecutionScope):
class DOMReadyStateChangeEventScope(EventTargetEventScopeBase, ImportantExecutionScope):
    def __init__(self, *args, readyState, **kwargs):
        EventTargetEventScopeBase.__init__(self, *args, **kwargs)
        # ImportantExecutionScope.__init__(self, *args, **kwargs)
        self.readyState = readyState
        pass

    def toString(self, succinct=True):
        s = super().toString(succinct)
        s += ' readyState "{readyState}"'.format(readyState=self.readyState)
        return s

    def _draw_get_scope_short_name(self):
        return 'stateChange'

    def draw_get_label(self):
        s = super().draw_get_label()
        return s + '\\n={}'.format(self.readyState)

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': dispatch '
    'event \[(?P<eventName>.*)\], state \[(?P<readyState>.*)\]: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='Document.cpp', functionName='setReadyState()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_doc_dispatching_readystatechange(log_event_info,
                                                scopeStart, docInstNum, action, eventName, readyState):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    docInstNum = int(docInstNum)
    _check_event_target_instNum(docInstNum)

    if docInstNum != g_main_doc.instNum:
        # we only deal with the main doc
        return

    assert eventName == 'readystatechange'

    doc = g_instNum_to_event_target[docInstNum]
    assert type(doc) == Document and doc.instNum == docInstNum

    assert readyState in _docReadyStates

    scopeClass = DOMReadyStateChangeEventScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1,
                           eventName=eventName, eventTargetInstNum=docInstNum,
                           readyState=readyState)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.readyState == readyState
        scope.close(ts, event_no, scopeStart=scopeStart)

        if scope.readyState != 'complete':
            # if the ready state is anything besides complete, for now we
            # expect that it doesn't do anything interesting
            assert (ts - scope.open_ts()) < 5.0

            # make sure no interesting edges were added to the scope
            # or its inner scopes
            assert not scope.out_edges(includeInnerScopes=True)
            pass
        else:
            eventName += '_complete'

            eventtarget = g_main_doc
            eventtarget.add_dom_event_handling_scope(eventName, scope)
            pass

        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=    846.84, ResourceFetcher.cpp :1318, incrementRequestCount(): ___ doc:7: fetcher:2, res:2, increments request count to 1
# t=1, ts=    865.10, ResourceFetcher.cpp :1337, decrementRequestCount(): ___ doc:7: fetcher:2, res:5, decrements request count to 10

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': ' + _fetcher_pattern_str + ', ' + _res_pattern_str + ', ' + \
    '(?P<action>[^ ]*) request count to (?P<reqCount>.*)$')
@_check_log_event_info(fileName='ResourceFetcher.cpp',
                       functionNames=('incrementRequestCount()', 'decrementRequestCount()'))
def _handle_wk_res_req_count_action(log_event_info,
                                    docInstNum, fetcherInstNum, resInstNum, action, reqCount):
    docInstNum, resInstNum, reqCount = list(map(int, (docInstNum, resInstNum, reqCount)))

    _check_event_target_instNum(docInstNum)
    _check_resInstNum(resInstNum)

    resource = g_known_resources[resInstNum]
    assert resource.type not in (ResourceType.MainResource,
                                 # ResourceType.LinkPrefetch,
                                 # ResourceType.LinkSubresource,
                                 # ResourceType.Media,
                                 ResourceType.Raw,
                                 # ResourceType.TextTrack,
                                 )

    if action == 'increments':
        resource.inc_req_count_by += 1
        resource.contributes_to_req_count = True
        if resource.inc_req_count_by > 1:
            assert resource.type == ResourceType.Font
            if scope_stack_size():
                outer_scope = outer_scope_at(0)
                assert isinstance(outer_scope, (FontFaceSetLoadPromiseExecutorScope, RenderTreeUpdateScope,
                                                RenderViewLayoutScope, V8Scope, LoadPendingFontsTimerFiredScope)), outer_scope
                pass
            pass
        pass
    elif action == 'decrements':
        resource.inc_req_count_by -= 1
        assert resource.inc_req_count_by >= 0
        if resource.inc_req_count_by > 1:
            assert resource.type == ResourceType.Font
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    pass

# t=1, ts=    846.29, NestingLevelIncrementer.h :52, NestingLevelIncrementer(): ___ scopeStart:1465228019262.526123: doc:7: parser:2: pumpTokenizer() (HTMLDocumentParser.cpp:636) recursionLevel up to 1
# t=1, ts=    849.75, NestingLevelIncrementer.h :63, ~NestingLevelIncrementer(): ___ scopeStart:1465228019262.526123: doc:7: parser:2: pumpTokenizer() (HTMLDocumentParser.cpp:636) recursionLevel down to 0

class _ParserPumpTokenizerScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass

    def draw_get_label(self):
        return 'parsing'

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _parser_pattern_str + ': pumpTokenizer\(\) \(.*\) recursionLevel (?P<action>[^ ]*) ' + \
    'to (?P<recursionLevel>.*)$')
@_check_log_event_info(fileName='NestingLevelIncrementer.h',
                       functionNames=('NestingLevelIncrementer()', '~NestingLevelIncrementer()'))
@_check_pushed_scope_has_scopeStart
def _handle_wk_doc_parser_pumptokenizer_scope_action(log_event_info,
                                                     scopeStart, docInstNum, parserInstNum, action, recursionLevel):
    docInstNum, recursionLevel = list(map(int, [docInstNum, recursionLevel]))
    _check_event_target_instNum(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _ParserPumpTokenizerScope

    if action == 'up':
        scope = scopeClass(ts, event_no, None,
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'down':
        scope = pop_scope()
        assert type(scope) == scopeClass, str(scope)
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


########

# t=1, ts=   1576.36, XMLHttpRequest.cpp :162, XMLHttpRequest(): ___ scopeStart:1465228019992.625977: doc:7: xmlhttprequest:1250, created

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _xhr_pattern_str + ', created$')
@_check_log_event_info(fileName='XMLHttpRequest.cpp', functionName='XMLHttpRequest()')
def _handle_wk_new_xhr(log_event_info,
                       scopeStart, docInstNum, xhrInstNum):
    docInstNum, xhrInstNum = list(map(int, [docInstNum, xhrInstNum]))
    _validate_instNum(xhrInstNum)
    assert xhrInstNum not in g_instNum_to_event_target

    assert is_executing_javascript()

    xhr = XMLHttpRequest(xhrInstNum,
                         creator_scope=current_important_scope(),
                         create_ts=log_event_info.ts)
    g_instNum_to_event_target[xhrInstNum] = xhr
    assert xhrInstNum not in g_xhrs
    g_xhrs[xhrInstNum] = xhr
    assert xhr.is_async is None
    return

# t=1, ts=   2245.10, XMLHttpRequest.cpp :893, createRequest(): ___ scopeStart:1469390592956.960938: doc:7: xmlhttprequest:1195, create async loader: begin
# t=1, ts=   1312.56, DocumentThreadableLoader.cpp :99, DocumentThreadableLoader(): ___ doc:8: threadableLoader:2, async= 1
# t=1, ts=   1312.57, DocumentThreadableLoader.cpp :518, loadRequest(): ___ scopeStart:1464718156978.099121: doc:8: threadableLoader:2 create async= 1 request, isPreflight= 0: begin
# .
# .
# .
# t=1, ts=   1312.70, DocumentThreadableLoader.cpp :518, loadRequest(): ___ scopeStart:1464718156978.099121: doc:8: threadableLoader:2 create async= 1 request, isPreflight= 0: done
# t=1, ts=   2245.27, XMLHttpRequest.cpp :893, createRequest(): ___ scopeStart:1469390592956.960938: doc:7: xmlhttprequest:1195, create async loader: done (dur= 0.169922)

class _XHRCreateLoaderScope1(UnimportantExecutionScope):
    def __init__(self, *args, xhr, **kwargs):
        super().__init__(*args, **kwargs)
        self.xhr = xhr
        assert type(xhr) is XMLHttpRequest
        pass

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _xhr_pattern_str + ', '
    'create async loader: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='XMLHttpRequest.cpp', functionName='createRequest()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_create_xhr_async_loader1(log_event_info,
                                        scopeStart, docInstNum, xhrInstNum, action):
    docInstNum, xhrInstNum = list(map(int, [docInstNum, xhrInstNum]))
    _check_event_target_instNum(xhrInstNum)

    assert is_executing_javascript()

    xhr = g_instNum_to_event_target[xhrInstNum]
    assert type(xhr) == XMLHttpRequest

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _XHRCreateLoaderScope1

    if action == 'begin':
        assert xhr.is_async is None
        xhr.is_async = True

        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1,
                           xhr=xhr)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=   1628.61, DocumentThreadableLoader.cpp :518, loadRequest(): ___ scopeStart:1465228020044.883057: doc:7: threadableLoader:1 create async= 1 request, isPreflight= 0: begin

class _XHRCreateLoaderScope2(UnimportantExecutionScope):
    def __init__(self, *args, xhr, **kwargs):
        super().__init__(*args, **kwargs)
        self.xhr = xhr
        assert type(xhr) is XMLHttpRequest
        pass

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'threadableLoader:(?P<threadableLoaderInstNum>.*) create async= (?P<isAsync>.*) ' + \
    'request, isPreflight= (?P<isPreflight>.*): ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='DocumentThreadableLoader.cpp', functionName='loadRequest()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_create_xhr_async_loader2(log_event_info,
                                 scopeStart, docInstNum, threadableLoaderInstNum,
                                 isAsync, isPreflight, action):
    docInstNum, threadableLoaderInstNum = list(map(int, [docInstNum, threadableLoaderInstNum]))
    _check_event_target_instNum(docInstNum)
    # assert docInstNum == g_main_doc.instNum

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    isAsync = _get_bool_from_int(int(isAsync))
    isPreflight = _get_bool_from_int(int(isPreflight))
    # assert isAsync and not isPreflight
    assert isAsync

    scopeClass = _XHRCreateLoaderScope2

    if action == 'begin':
        immediate_outer_scope = outer_scope_at(0)

        # we might be handling a fetch finish scope, e.g. handling the
        # finish of the preflight request (e.g., "OPTIONS" http
        # request) for the xmlhttprequest, and now creates a new
        # loader for the actual request

        if (type(immediate_outer_scope) is _XHRCreateLoaderScope1):
            xhr = immediate_outer_scope.xhr
            pass
        elif (type(immediate_outer_scope) is FetchFinishScope):
            # # xhr.resource_chain
            # assert False
            xhr = g_resInstNum_to_xhr[immediate_outer_scope.resInstNum]
            pass
        else:
            raise Exception("unexpected outer scope: {scope}".format(immediate_outer_scope))

        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1,
                           xhr=xhr)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


########


# t=1, ts=     86.08, ResourceFetcher.cpp :1629, willStartLoadingResource(): ___ doc:8: fetcher:3, really starts loading res:3, type [...] url [...] method [GET] context= [...] priority=3, isDataURL= 0, 1 depParent(s)= [...]

# this one has no "doc:N" because it's the first resource
# t=1, ts=      1.32, ResourceFetcher.cpp :1671, willStartLoadingResource(): ___ fetcher:2, really starts loading res:1, type [MainResource] url [http://www.berkeley.edu/] method [GET] context= [Location] priority=4, isDataURL= 0, 0 depParent(s)= []


@g_log_processor.register(
    r'^((' + _doc_pattern_str + ': )?fetcher:(?P<fetcherInstNum>\d+), )?'
    'really starts loading ' + _res_pattern_str + ', type \[.+\] '
    'url \[(?P<url>.+)\] '
    'method \[(?P<method>.+)\] context= \[.+\] priority=(?P<priority>\d+), '
    'isDataURL= (?P<isDataURL>[\d+]), .*$')
@_check_log_event_info(fileName='ResourceFetcher.cpp', functionName='willStartLoadingResource()')
def _handle_wk_fetcher_starts_loading_res(log_event_info,
                                          docInstNum, fetcherInstNum, resInstNum,
                                          url, method, priority, isDataURL):
    resInstNum, isDataURL, priority = list(map(int, (resInstNum, isDataURL, priority)))
    isDataURL = _get_bool_from_int(isDataURL)
    assert url != _not_shown_url or isDataURL
    _check_resInstNum(resInstNum)

    assert resInstNum not in g_fetched_instNum_to_resource
    resource = g_known_resources[resInstNum]

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    g_fetched_instNum_to_resource[resInstNum] = resource
    if not isDataURL:
        # assert url not in g_fetched_url_to_resource
        # g_fetched_url_to_resource[url] = resource

        assert resInstNum not in g_fetched_url_to_resources[url]
        g_fetched_url_to_resources[url][resInstNum] = resource
        pass

    outer_scope = current_important_scope()

    # if resInstNum == 196:
    #     pdb.set_trace()
    #     pass

    if (find_outer_scope((RenderTreeUpdateScope, LoadPendingFontsTimerFiredScope, FetchFinishScope)) is None) and \
      not is_executing_javascript():
        # if we're within one of these scopes: render tree update, v8,
        # microtask checkpoint, fetch finish (*), then we assume the
        # fetch is not caused by main html. e.g., maybe the resource
        # is *created* by main html as part of some element (?), but
        # not until js runs and modifies some attributes that the
        # fetch starts, and so we only care about that.
        #
        # (*) fetch finish case: for example, in xmlhttprequest case,
        # it can fetch a (preflight) resource (e.g., OPTIONS request),
        # then when that is finished, while in the FetchFinishScope of
        # that resource, it starts loading a new resource
        #
        # so, if we are NOT in one of these 3 types of scopes, then
        # assume we are started cuz of the main html, so we set the
        # scope to None so we use this fact later
        outer_scope = None
        pass
    else:
        if find_outer_scope(_XHRCreateLoaderScope2):
            # handle xhr specially

            _outer_scope = outer_scope_at(0)
            assert type(_outer_scope) is _XHRCreateLoaderScope2, '{}'.format(_outer_scope)

            # the scope that create the xhr can be different that the
            # one that starts loading it, e.g., a script can create
            # the xhr and schedule a 1-second timer to actually start
            # loading.
            #
            # since we only care about actual loading, if the creating
            # and loading scopes are different we overwrite the
            # creating scope, replacing it with the load starting
            # scope

            xhr = _outer_scope.xhr
            assert xhr.creator_scope is not None

            if not xhr.resource_chain:
                # if xhr.instNum == 3778:
                #     pdb.set_trace()
                # if this is the FIRST resource load in the xhr
                if xhr.creator_scope is not current_important_scope():
                    xhr.override_creation_info(current_important_scope(), ts)
                    pass
                pass

                # creation of the xhr and its resource loading should
                # be only a few milliseconds apart
                assert 0 <= (ts - xhr.create_ts) < 4, '{} {}'.format(ts, xhr.create_ts)
                # assert xhr.resource is None
                # xhr.resource = resource
            else:
                # this is not the first resource that the xhr
                # requested, then we must be handling a
                # FetchFinishScope
                assert find_outer_scope(FetchFinishScope) is not None
                pass

            # assert url not in g_url_to_xhr
            # g_url_to_xhr[url] = xhr

            assert resInstNum not in g_resInstNum_to_xhr
            g_resInstNum_to_xhr[resInstNum] = xhr

            xhr.resource_chain.append(resInstNum)

            # we make the xhr -- instead of the scope -- schedule the
            # fetch
            outer_scope = None
            pass
        pass

    fetchreq = resource.starts_fetching(
        starter_scope=outer_scope, method=method, priority=priority, ts=ts)

    g_all_fetch_requests.append(fetchreq)

    return


# t=1, ts=   2479.84, ResourceFetcher.cpp :1474, willSendRequest(): ___ doc:7: fetcher:2, starts following redirect for res:198, to new url [...] method [GET]

@g_log_processor.register(
    r'^((' + _doc_pattern_str + ': )?fetcher:(?P<fetcherInstNum>\d+), )?'
    'starts following redirect for ' + _res_pattern_str + ', to new '
    'url \[(?P<url>.+)\] '
    'method \[(?P<method>.+)\]$')
@_check_log_event_info(fileName='ResourceFetcher.cpp', functionName='willSendRequest()')
def _handle_wk_fetcher_starts_following_redirect(log_event_info,
                                          docInstNum, fetcherInstNum, resInstNum,
                                          url, method):
    resInstNum = int(resInstNum)
    assert url != _not_shown_url
    _check_resInstNum(resInstNum)

    assert resInstNum in g_fetched_instNum_to_resource
    resource = g_fetched_instNum_to_resource[resInstNum]

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    return

########

# t=1, ts=    898.51, StyleSheetContents.cpp :329, parseAuthorStyleSheet(): ___ scopeStart:1464455334381.947998: doc:8: this 0x3b22d7c6cc70 parse style sheet res:4: begin
# t=1, ts=    899.19, StyleSheetContents.cpp :329, parseAuthorStyleSheet(): ___ scopeStart:1464455334381.947998: doc:8: this 0x3b22d7c6cc70 parse style sheet res:4: done

class ParseCSSStyleSheetScope(ImportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.resInstNum = None
        pass
    pass

@g_log_processor.register(
    r'^'  + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': this 0x.+ parse style sheet ' + _res_pattern_str + ': ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='StyleSheetContents.cpp', functionName='parseAuthorStyleSheet()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_stylesheet_res_parse(log_event_info,
                                    scopeStart, docInstNum, resInstNum, action):
    docInstNum, resInstNum = list(map(int, (docInstNum, resInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_resInstNum(resInstNum)

    resource = g_fetched_instNum_to_resource[resInstNum]
    assert type(resource) == StyleSheetResource

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = ParseCSSStyleSheetScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        if scope.count_out_edges(True):
            resource.parse_scope = scope
            pass
        else:
            resource.parse_duration = scope.duration()
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    pass

########

# t=1, ts=    845.81, Document.cpp :588, Document(): ___ doc:7: ctor url: [http://www.berkeley.edu/] parentDoc:0 ownerDoc:0 contextDoc:0 fetcher:2

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': ctor '
    'url: \[(?P<url>.+)\] '
    'parentDoc:(?P<parentDocInstNum>.*) ownerDoc:(?P<ownerDocInstNum>.*) '
    'contextDoc:(?P<contextDocInstNum>.*) ' + _fetcher_pattern_str + '$')
@_check_log_event_info(fileName='Document.cpp', functionName='Document()')
def _handle_wk_document_ctor(log_event_info,
                             docInstNum, url,
                             parentDocInstNum, ownerDocInstNum, contextDocInstNum, fetcherInstNum):
    docInstNum, parentDocInstNum, ownerDocInstNum, contextDocInstNum, fetcherInstNum = list(
        map(int, (docInstNum, parentDocInstNum, ownerDocInstNum, contextDocInstNum, fetcherInstNum)))

    _validate_instNum(docInstNum)

    global g_main_resource
    # due to redirect, the main resource can start out as
    # "http://www.foo.com/" and become "https://www.foo.com/". the log
    # does have this information, logged by
    # http_network_transaction.cc Start() method. so we should add
    # logic to follow that (because the redirect can change more parts
    # of the url), but for now, just strip off the scheme and compare
    # the rest
    if (urlparse(url)[1:] == urlparse(g_main_resource.url)[1:]):
        assert docInstNum == 7

        # this is main document
        assert parentDocInstNum == ownerDocInstNum == contextDocInstNum == 0
        assert fetcherInstNum == 2
        assert docInstNum not in g_instNum_to_event_target

        global g_main_doc
        assert g_main_doc is None
        g_main_doc = Document(docInstNum,
                              creator_scope=current_important_scope(),
                              create_ts=log_event_info.ts)
        g_instNum_to_event_target[docInstNum] = g_main_doc

        assert g_main_resource is not None
        ReferencingEdge(src=g_main_doc, dst=g_main_resource)
        pass
    else:
        # if url != 'about:blank' and not url in g_unhandled_iframes:
        #     assert find_outer_scope(V8Scope) is not None
        #     pass
        g_instNum_to_event_target[docInstNum] = Document(
            docInstNum, creator_scope=current_important_scope(),
            create_ts=log_event_info.ts)
        pass

    pass

# t=1, ts=      0.21, LocalDOMWindow.cpp :351, LocalDOMWindow(): ___ window:1: created

@g_log_processor.register(
    _window_pattern_str + ': created$')
@_check_log_event_info(fileName='LocalDOMWindow.cpp', functionName='LocalDOMWindow()')
def _handle_wk_dom_window_created(log_event_info, windowInstNum):
    windowInstNum = int(windowInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    assert windowInstNum not in g_instNum_to_event_target
    g_instNum_to_event_target[windowInstNum] = EventTarget(
        windowInstNum, creator_scope=current_important_scope(), create_ts=ts) # just to add the entry

    pass

# t=1, ts=    845.87, LocalDOMWindow.cpp :418, installNewDocument(): ___ scopeStart:1465228019262.140137: doc:7: installed on window:1: begin
# t=1, ts=    845.89, LocalDOMWindow.cpp :418, installNewDocument(): ___ scopeStart:1465228019262.140137: doc:7: installed on window:1: done (dur= 0.018311)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': installed on ' + _window_pattern_str + ': ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='LocalDOMWindow.cpp', functionName='installNewDocument()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_dom_window_install_document_scope_action(log_event_info,
                                                        scopeStart, docInstNum, windowInstNum, action):
    docInstNum, windowInstNum = list(map(int, (docInstNum, windowInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(windowInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _MinimalDummyScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.open_event_seq_no() == (event_no - 1)
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    pass


class OpenURLScope(ImportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.url = None
        pass
    pass

# t=1, ts=   1980.41, HTMLFrameElementBase.cpp :80, openURL(): ___ scopeStart:1469390553841.949951: doc:7: frame elem:3558 openurl [...]: begin

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': frame ' + _elem_pattern_str + ' openurl \[(?P<url>.*)\]: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='HTMLFrameElementBase.cpp', functionName='openURL()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_frame_openurl_scope_action(log_event_info,
                                          scopeStart, docInstNum, elemInstNum, url, action):
    docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == IFrameElement

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = OpenURLScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           scopeStart=scopeStart)
        push_scope(scope)
        scope.url = url
        parsed = urlparse(url)
        # assert not parsed.scheme.startswith('http'), 'not yet supporting real http iframes'
        if parsed.scheme.startswith('http'):
            logging.warn('not yet supporting real http iframes (url [{url}]'.format(
                url=url))
            g_unhandled_iframes.add(url)
            return
            pass
        pass
    elif action == 'done':
        scope = pop_scope()
        scope.close(ts, event_no, scopeStart=scopeStart)
        assert url == scope.url
        parsed = urlparse(scope.url)
        if not parsed.scheme.startswith('http'):
            if find_outer_scope(V8Scope):
                # we are an uninteresting scope inside a v8scope, we
                # can drop ourselves
                scope.drop()
                pass
            else:
                assert scope.count_in_edges(True) == 0
                assert scope.count_out_edges(True) == 0
                pass
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    pass


########

# the insertionpointrecord saves the unparsed bytes in the html input
# stream before doing script processing because script can do
# doc.write(), which inserts the text in front of the current bytes in
# the input stream.

########

# preload scanner stuff. there are several locations where we invoke
# the preload scanner, but they are all in HTMLDocumentParser.cpp

# t=1, ts=    613.08, HTMLDocumentParser.cpp :724, pumpTokenizer(): ___ scopeStart:1464455334096.521973: doc:8: preloadscanning: begin
# t=1, ts=    614.39, HTMLDocumentParser.cpp :724, pumpTokenizer(): ___ scopeStart:1464455334096.521973: doc:8: preloadscanning: done

class _PreloadScanningScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'preloadscanning: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='HTMLDocumentParser.cpp',
                       functionNames=('pumpTokenizer()', 'append()', 'insert()'))
@_check_pushed_scope_has_scopeStart
def _handle_wk_preload_scanner_action(log_event_info,
                                      scopeStart, docInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _PreloadScanningScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, None,
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

########

# currently we only see dom microtasks used for loading images, so we
# don't have to make general dommicrotasks
#
# 08/11/2016: microtasks are run before the v8scope exits, so we can
# have all these microtasks stuff part of the v8scope (i.e.,
# SchedulingEdgeWithTs)

# t=1, ts=   1736.83, ImageLoader.cpp :229, enqueueImageLoadingMicroTask(): ___ scopeStart:1464910015614.150879: doc:8: enqueue dommicrotask to load img elem:1166: begin
# t=1, ts=   1736.84, Microtask.cpp :83, enqueueMicrotask(): ___ enqueing dommicrotask:2
# t=1, ts=   1736.84, Document.cpp :5511, incrementLoadEventDelayCount(): ___ doc:8: new loadEventDelayCount: 1
# t=1, ts=   1736.85, ImageLoader.cpp :229, enqueueImageLoadingMicroTask(): ___ scopeStart:1464910015614.150879: doc:8: enqueue dommicrotask to load img elem:1166: done (dur= 0.015137)

# class _EnqueueDOMMicrotaskToLoadImgScope(UnimportantExecutionScope):
#     # this scope is expected to do nothing else other enqueuing a
#     # microtask
#     def __init__(self, *args, **kwargs):
#         super().__init__(*args, **kwargs)
#         pass
#     pass

# @g_log_processor.register(
#     r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
#     'enqueue dommicrotask to load img ' + _elem_pattern_str + ': ' + \
#     _scope_action_pattern_str + '$')
# @_check_log_event_info(fileName='ImageLoader.cpp', functionName='enqueueImageLoadingMicroTask()')
# def _handle_wk_enqueue_dommicrotask_scope_action(log_event_info,
#                                                  scopeStart, docInstNum, action, elemInstNum):
#     ts = log_event_info.ts
#     event_no = log_event_info.log_event_No

#     docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

#     assert elemInstNum in g_instNum_to_event_target

#     scopeClass = _EnqueueDOMMicrotaskToLoadImgScope

#     if action == 'begin':
#         # giving None to the scope constructor so that the outer scope
#         # doesn't add the new scope as an inner
#         scope = scopeClass(ts, event_no, outer_scope=None,
#                            recursionLevel=1,
#                            scopeStart=scopeStart)
#         push_scope(scope)
#         pass
#     elif action == 'done':
#         scope = pop_scope()
#         assert type(scope) is scopeClass and not scope.outer_scope(), \
#           '{} {}'.format(str(scope), str(scope.outer_scope()))
#         scope.close(ts, event_no, scopeStart=scopeStart)
#         assert scope.open_event_seq_no() == (event_no - 3)
#         pass
#     else:
#         raise Exception('unexpected action "{}"'.format(action))
#     return

# t=1, ts=   1477.08, ImageLoader.cpp :357, updateFromElement(): ___ doc:7: image elem:1823 makes dommicrotask:8 no-op

# @g_log_processor.register(
#     r'^' + _doc_pattern_str + ': image ' + _elem_pattern_str + ' ' + \
#     ' makes ' + _dommicrotask_pattern_str + ' no-op$')
# @_check_log_event_info(fileName='ImageLoader.cpp', functionName='updateFromElement()')
# def _handle_wk_image_loader_noopify_microtask(log_event_info,
#                                               docInstNum, elemInstNum, taskInstNum):
#     docInstNum = int(docInstNum)
#     elemInstNum = int(elemInstNum)
#     _check_event_target_instNum(elemInstNum)
#     taskInstNum = int(taskInstNum)

#     pass

########

# t=1, ts=    824.11, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise:11: begin]
# t=1, ts=    824.12, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise microtask enqueued for promise:11: taskID:8: numtasks= 2]
# t=1, ts=    824.12, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise:11:   done]

class _SettlePromiseScope(UnimportantExecutionScope):
    # this scope is expected to do nothing else other enqueuing a
    # microtask
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    '(?P<promiseSettleType>(resolve|reject)) ' + _promise_pattern_str + ': (  )?(?P<action>[^ ]*)' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_settling_promise_scope_action(log_event_info, who,
                                             promiseSettleType, promiseInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum = int(promiseInstNum)

    if _ignore_promiseInstNums(promiseInstNum):
        return

    assert promiseInstNum in g_promises

    assert promiseSettleType in ('resolve', 'reject'), \
      'unexpected promise action type "{}"'.format(promiseSettleType)

    scopeClass = _SettlePromiseScope

    if action == 'begin':
        assert current_important_scope()
        g_promises[promiseInstNum].set_settler_scope(
            current_important_scope(), type=promiseSettleType, ts=ts)
        # giving None to the scope constructor so that the outer scope
        # doesn't add the new scope as an inner
        scope = scopeClass(ts, event_no, outer_scope=None,
                           recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass and scope.open_event_seq_no() == (event_no - 2)
        scope.close(ts, event_no)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    824.12, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise microtask enqueued for promise:11: taskID:8: numtasks= 2]

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    '(?P<promiseSettleType>.*) promise microtask enqueued for ' + _promise_pattern_str + ': ' + \
    _promise_microtaskID_pattern_str + ': numtasks= (?P<numTasks>.*)' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_promise_microtask_enqueued(log_event_info, who,
                                          promiseSettleType, promiseInstNum, taskID, numTasks):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    assert promiseSettleType in ('resolve', 'reject'), \
      'unexpected promise settle type "{}"'.format(promiseSettleType)

    promiseInstNum, taskID, numTasks = list(map(int, (promiseInstNum, taskID, numTasks)))

    if _ignore_promiseInstNums(promiseInstNum):
        return

    assert promiseInstNum in g_promises and not (numTasks % 2)

    assert type(outer_scope_at(0)) is _SettlePromiseScope and \
      outer_scope_at(0).open_event_seq_no() == (event_no - 1)

    assert taskID not in g_promise_microtasks
    g_promise_microtasks[taskID] = PromiseMicrotask(
        taskID=taskID, scheduler_scope=current_important_scope(),
        schedule_ts=ts, promiseInstNum=promiseInstNum)

    return

########

# t=1, ts=    809.24, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [running resolve promise microtask for promise:3: begin, taskID:2: numtasks= 2]
# t=1, ts=    809.35, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3: begin]
# t=1, ts=    809.38, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3: begin calling handler]
# t=1, ts=    809.56, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [resolve promise:2: begin]
# t=1, ts=    809.60, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [resolve promise microtask enqueued for promise:2: taskID:3: numtasks= 2]
# t=1, ts=    809.62, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [resolve promise:2:   done]
# t=1, ts=    809.63, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3:   done calling handler]
# t=1, ts=    810.44, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3: result= [undefined]]
# t=1, ts=    810.49, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3: begin resolving promise:4]
# t=1, ts=    810.54, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise:4: begin]
# t=1, ts=    810.56, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise microtask enqueued for promise:4: taskID:4: numtasks= 0]
# t=1, ts=    810.57, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [resolve promise:4:   done]
# t=1, ts=    810.58, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3:   done resolving promise:4]
# t=1, ts=    810.59, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [handle promise:3:   done]
# t=1, ts=    810.61, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [unknown:-1]: [running resolve promise microtask for promise:3:   done, taskID:2:]

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'running (?P<promiseSettleType>.*) promise microtask for ' + _promise_pattern_str + ': ' + \
    '(  )?(?P<action>[^ ]*), ' + _promise_microtaskID_pattern_str + ':( numtasks= (?P<numTasks>.*))?' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_run_promise_microtask_scope_action(log_event_info, who,
                                                  promiseSettleType, promiseInstNum, action,
                                                  taskID, numTasks):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum, taskID = list(map(int, (promiseInstNum, taskID)))

    if _ignore_promiseInstNums(promiseInstNum):
        return

    assert promiseInstNum in g_promises

    assert taskID in g_promise_microtasks, taskID
    promise_microtask = g_promise_microtasks[taskID]
    assert type(promise_microtask) is PromiseMicrotask

    if promiseSettleType == 'resolve':
        scopeClass = RunMicrotaskScope
        pass
    elif promiseSettleType == 'reject':
        scopeClass = RunMicrotaskScope
        pass
    else:
        raise Exception('unexpected promise action type "{}"'.format(promiseSettleType))
        pass

    if action == 'begin':
        numTasks = int(numTasks)
        assert not (numTasks % 2) # must be odd

        scope = scopeClass(ts, event_no, outer_scope=current_important_scope(), recursionLevel=1)
        push_scope(scope)

        g_promises[promiseInstNum].set_onSettle_microtask_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


########

# t=1, ts=   1712.91, Microtask.cpp :58, performCheckpoint(): ___ scopeStart:1464910015590.226807: microtask checkpoint, initiated by [WebKit.cpp:79, didProcessTask()] []: begin
# t=1, ts=   1714.18, Microtask.cpp :58, performCheckpoint(): ___ scopeStart:1464910015590.226807: microtask checkpoint, initiated by [WebKit.cpp:79, didProcessTask()] []: done (dur= 1.266113)

class _PerformMicrotaskCheckpointScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.num_tasks_run = 0
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': microtask checkpoint, ' + \
    'initiated by \[(?P<initiatorLocation>.*)\] \[(?P<msg>.*)\]: ' + \
    _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='Microtask.cpp', functionName='performCheckpoint()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_perform_microtask_checkpoint_scope_action(log_event_info,
                                                         scopeStart, initiatorLocation, msg, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    # for now require that we're in a v8 scope, but according to the
    # spec, it doesn't have to be: i.e., microtask checkpoint is be
    # performed after a task is run. see
    # https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model. on
    # webkit it's the EndOfTaskRunner::didProcessTask() in WebKit.cpp
    # assert find_outer_scope(V8Scope)

    scopeClass = _PerformMicrotaskCheckpointScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass and scope.num_tasks_run > 0
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


# t=1, ts=   1239.27, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [../../v8/src/isolate.cc:2320]: [run ONE microtask: scopeStart:1464455334722.707031: begin]
# t=1, ts=   1240.47, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [../../v8/src/isolate.cc:2358]: [run ONE microtask: scopeStart:1464455334722.707031: done]

class _RunOneMicrotaskScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'run ONE microtask: ' + _scopeStart_pattern_str + ': (?P<action>[^ ]*)' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_run_one_microtask_scope_action(log_event_info, who,
                                              scopeStart, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _RunOneMicrotaskScope

    if action == 'begin':
        outer_scope = outer_scope_at(0)
        assert type(outer_scope) is _PerformMicrotaskCheckpointScope
        outer_scope.num_tasks_run += 1

        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    elif action.find('ERROR') >= 0:
        raise Exception('error encountered while running microtask')
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

########

# t=1, ts=    629.33, Document.cpp :3334, didLoadAllScriptBlockingResources(): ___ doc:8: done loading all script blocking resources. start executeScriptsWaitingForResourcesTimer

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': done loading all script blocking resources. start executeScriptsWaitingForResourcesTimer$')
@_check_log_event_info(fileName='Document.cpp', functionName='didLoadAllScriptBlockingResources()')
def _handle_wk_schedule_execute_blocked_scripts(log_event_info,
                                                docInstNum):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    # global g_scheduled_execution_of_scripts_blocked_by_style_resources
    # if g_scheduled_execution_of_scripts_blocked_by_style_resources:
    #     # this can be scheduled multiple times idempotently, e.g., a
    #     # script can insert dynamic html that contains multiple
    #     # <style> elements, so after each style element is parsed, we
    #     # can reach here
    #     find_outer_scope((V8Scope, _ParserPumpTokenizerScope))
    #     edge = g_scheduled_execution_of_scripts_blocked_by_style_resources
    #     src = edge.src()
    #     assert (src is current_important_scope()) and (edge.dst() is None)
    #     # remove the previous edge from
    #     src.remove_out_edge(edge)
    #     del edge
    #     pass
    # g_scheduled_execution_of_scripts_blocked_by_style_resources = \
    #   SchedulingEdgeWithTs(current_important_scope(), None, ts=ts)

    return


########

# t=1, ts=   1405.68, Document.cpp :3328, executeScriptsWaitingForResourcesTimerFired(): ___ scopeStart:1464910015283.001953: doc:8: execute scripts blocked by style resources: begin
# t=1, ts=   1444.75, Document.cpp :3328, executeScriptsWaitingForResourcesTimerFired(): ___ scopeStart:1464910015283.001953: doc:8: execute scripts blocked by style resources: done (dur= 39.062012)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'execute scripts blocked by style resources: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='Document.cpp', functionName='executeScriptsWaitingForResourcesTimerFired()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_execute_scripts_waiting_for_style_resources_scope_action(log_event_info,
                                                                        scopeStart, docInstNum, action):
    docInstNum = int(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    _check_event_target_instNum(docInstNum)

    scopeClass = ExecuteScriptsWaitingForStyleResourcesScope

    # if action == 'begin':
    #     scope = scopeClass(ts, event_no, current_important_scope(),
    #                        scopeStart=scopeStart, recursionLevel=1)
    #     push_scope(scope)

    #     global g_scheduled_execution_of_scripts_blocked_by_style_resources
    #     assert g_scheduled_execution_of_scripts_blocked_by_style_resources is not None
    #     g_scheduled_execution_of_scripts_blocked_by_style_resources.set_dst(scope)
    #     g_scheduled_execution_of_scripts_blocked_by_style_resources = None
    #     pass
    # elif action == 'done' or action == 'NOT':
    #     scope = pop_scope()
    #     assert type(scope) == scopeClass
    #     scope.close(ts, event_no, scopeStart=scopeStart)
    #     pass
    # else:
    #     raise Exception('unexpected action "{}"'.format(action))

    return


########

def _check_v8_scope_transition(recursionLevelRange):
    def decorator(func):
        @wraps(func)
        def func_wrapper(log_event_info, *args, **kwargs):
            at = kwargs['at']
            recursionLevel = int(kwargs['recursionLevel'])
            assert at in ('V8ScriptRunner.cpp:187, runCompiledScript()',
                          'V8ScriptRunner.cpp:264, callFunction()')
            assert recursionLevelRange[0] <= recursionLevel <= recursionLevelRange[-1]
            return func(log_event_info, *args, **kwargs)
        return func_wrapper
    return decorator

# for now we expect at most one nested v8 scope, i.e., entering one
# inner v8 scope while in an outer v8 scope

# t=1, ts=   1972.34, V8RecursionScope.h :78, V8RecursionScope(): ___ enter scope at [V8ScriptRunner.cpp:264, callFunction(): doc:3493], recursionLevel up to 2

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': enter scope at \[(?P<at>.+): ' + _doc_pattern_str + '\], '
    'recursionLevel up to (?P<recursionLevel>\d+)$')
@_check_log_event_info(fileName='V8RecursionScope.h', functionName='V8RecursionScope()')
@_check_v8_scope_transition((1, 2))
@_check_pushed_scope_has_scopeStart
def _handle_wk_enter_v8_recursion_scope(log_event_info,
                                        scopeStart, at, docInstNum, recursionLevel):
    recursionLevel = int(recursionLevel)

    ts = log_event_info.ts

    # if recursionLevel == 2:
    #     # special case for AdFuelCreated event that cnn fires
    #     outer_scope = outer_scope_at(0)
    #     assert (type(outer_scope) is EventTargetInvokingOneListenerScope and \
    #             outer_scope.eventName == 'AdFuelCreated') \
    #             or \
    #             (type(outer_scope) is _MinimalDummyScope and \
    #             type(outer_scope_at(1) is OpenURLScope))
    #     pass

    is_handling_special_event = False
    if scope_stack_size():
        outer_scope = outer_scope_at(0)
        if (type(outer_scope) is EventTargetInvokingOneListenerScope) and \
          (outer_scope.eventName in ('message', 'deviceorientation', 'progress')):
            is_handling_special_event = True
            pass
        pass

    scope = V8Scope(ts, log_event_info.log_event_No, current_important_scope(),
                    scopeStart=scopeStart, recursionLevel=recursionLevel)
    push_scope(scope)

    if is_handling_special_event:
        # don't blindly set to is_handling_special_event
        scope.set_to_be_pruned(True)
        pass

    g_v8_scopes.append(scope)

    return


@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': exit scope at \[(?P<at>.+): ' + _doc_pattern_str + '\], '
    'recursionLevel down to (?P<recursionLevel>\d+)$')
@_check_log_event_info(fileName='V8RecursionScope.h', functionName='~V8RecursionScope()')
@_check_v8_scope_transition((0, 1))
def _handle_wk_exit_v8_recursion_scope(log_event_info,
                                       scopeStart, at, docInstNum, recursionLevel):
    recursionLevel = int(recursionLevel)
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scope = pop_scope()
    assert type(scope) == V8Scope, 'unexpected scope {scope}'.format(scope=scope)
    assert scope.open_ts() <= ts and not scope.has_closed() \
      and scope.recursion_level() == (recursionLevel + 1)
    scope.close(ts, event_no, scopeStart=scopeStart)

    return

# t=1, ts=    739.44, NestingLevelIncrementer.h :52, NestingLevelIncrementer(): ___ scopeStart:1462519939526.348145: doc:8: doc.write() 82 bytes, ownerDoc:8, script [http://www.berkeley.edu/] recursionLevel up to 1
# t=1, ts=    739.93, NestingLevelIncrementer.h :63, ~NestingLevelIncrementer(): ___ scopeStart:1462519939526.348145: doc:8: doc.write() 82 bytes, ownerDoc:8, script [http://www.berkeley.edu/] recursionLevel down to 0

class _DocWriteScope(UnimportantExecutionScope):
    def __init__(self, *args, numBytes, **kwargs):
        super().__init__(*args, **kwargs)
        self.numBytes = numBytes
        pass

    def toString(self, *args, **kwargs):
        s = super().toString(*args, **kwargs)
        s += ' numBytes:{numBytes}'.format(numBytes=self.numBytes)
        return s

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': doc\.write\(\) (?P<numBytes>\d+) bytes, '
    'ownerDoc:(?P<ownerDocInstNum>\d+), script \[(?P<url>.*)\] '
    'recursionLevel (?P<action>[^ ]*) to (?P<recursionLevel>\d+)$')
@_check_log_event_info(fileName='NestingLevelIncrementer.h',
                       functionNames=('NestingLevelIncrementer()', '~NestingLevelIncrementer()'))
@_check_pushed_scope_has_scopeStart
def _handle_wk_doc_write_scope_action(log_event_info,
                                      scopeStart, docInstNum, numBytes, ownerDocInstNum, url, action, recursionLevel):
    numBytes, recursionLevel = list(map(int, (numBytes, recursionLevel)))
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    numBytes = int(numBytes)

    scopeClass = _DocWriteScope

    if action == 'up':
        scope = scopeClass(ts, event_no, None, recursionLevel=recursionLevel,
                           scopeStart=scopeStart, numBytes=numBytes)
        push_scope(scope)
        pass
    elif action == 'down':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.numBytes == numBytes
        assert scope.recursion_level() == (recursionLevel + 1)
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=   1270.67, HTMLDocumentParser.cpp :788, insert(): ___ scopeStart:1465228019686.935059: doc:7: parser:2: parsingFragment= 0, insert 82 bytes, contextForParsingSession:7: begin

class _ParserInsertScope(UnimportantExecutionScope): # maybe nestable?
    # this is for htmldocumentparser::insert() stuff. we want this
    # call to parse all of the inserted bytes; otherwise, we'd have to
    # look into it
    def __init__(self, *args, numInsertedBytes, parsingFragment, parser, **kwargs):
        super().__init__(*args, **kwargs)
        self.numInsertedBytes = numInsertedBytes
        self.parsingFragment = parsingFragment
        self.parser = parser
        assert self.parsingFragment == self.parser.isParsingFragment
        pass

    def toString(self, *args, **kwargs):
        s = super().toString(*args, **kwargs)
        s += ' numBytes:{numBytes}'.format(numBytes=self.numInsertedBytes)
        return s

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _parser_pattern_str + ': ' \
    'parsingFragment= (?P<parsingFragment>\d*), insert ' \
    '(?P<numInsertedBytes>\d*) bytes, contextForParsingSession:(?P<contextInstNum>\d*): ' + \
    _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='HTMLDocumentParser.cpp', functionName='insert()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_doc_parser_insert_scope_action(log_event_info,
                                              scopeStart, docInstNum, parserInstNum, parsingFragment,
                                              action, numInsertedBytes, contextInstNum):
    docInstNum, parserInstNum, numInsertedBytes = list(map(int, (docInstNum, parserInstNum, numInsertedBytes)))

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    parsingFragment = _get_bool_from_int(int(parsingFragment))

    scopeClass = _ParserInsertScope

    if action == 'begin':
        immediate_outer_scope = outer_scope_at(0)
        if type(immediate_outer_scope) is _DocWriteScope:
            assert not parsingFragment
            pass
        elif type(immediate_outer_scope) is _CreatingFragmentScope:
            assert parsingFragment
            pass
        else:
            raise NotImplementedError
        assert immediate_outer_scope.open_event_seq_no() == (event_no - 1)

        if parserInstNum not in g_html_doc_parsers:
            parser = HTMLDocumentParser(
                instNum=parserInstNum, isParsingFragment=parsingFragment)
            g_html_doc_parsers[parserInstNum] = parser
            pass
        parser = g_html_doc_parsers[parserInstNum]

        if parsingFragment:
            g_html_doc_parsers[parserInstNum].fragmentInstNum = immediate_outer_scope.fragmentInstNum
            pass

        # assert numParsedInsertedBytes is None
        scope = scopeClass(ts, event_no, None,
                           recursionLevel=1, scopeStart=scopeStart,
                           numInsertedBytes=numInsertedBytes, parsingFragment=parsingFragment,
                           parser=parser)
        push_scope(scope)
        pass
    elif action == 'done':
        # numParsedInsertedBytes = int(numParsedInsertedBytes)
        scope = pop_scope()
        assert type(scope) == scopeClass
        assert scope.parsingFragment == scope.parsingFragment
        if parsingFragment:
            # assert 0 == numParsedInsertedBytes
            pass
        else:
            assert scope.numInsertedBytes == numInsertedBytes
            pass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return



###### general elements stuff

# t=1, ts=     71.82, Element.cpp :143, logByteRange(): ___ doc:8: elem:11 tag [html] byte range [15, 34]

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': ' + _elem_pattern_str + ' '
    'tag \[(?P<tag>.*)\] byte range \[(?P<start>\-?\d+), (?P<end>\-?\d+)\]$')
@_check_log_event_info(fileName='Element.cpp', functionName='logByteRange()')
def _handle_elem_byte_range(log_event_info,
                            docInstNum, elemInstNum, tag, start, end):
    docInstNum, elemInstNum, start, end = list(map(int, [docInstNum, elemInstNum, start, end]))
    _validate_instNum(elemInstNum)

    if docInstNum != g_main_doc.instNum:
        # if not for main doc, just ignore
        return

    if tag.lower() == 'body':
        global g_body_element
        assert g_body_element is None
        g_body_element = BodyElement(elemInstNum, current_important_scope(),
                                     create_ts=log_event_info.ts)
        assert elemInstNum not in g_instNum_to_event_target
        g_instNum_to_event_target[elemInstNum] = g_body_element
        pass
    elif tag.lower() == 'html':
        global g_html_element
        assert g_html_element is None
        g_html_element = HtmlElement(elemInstNum, current_important_scope(),
                                     create_ts=log_event_info.ts)
        assert elemInstNum not in g_instNum_to_event_target
        g_instNum_to_event_target[elemInstNum] = g_html_element
        pass

    if elemInstNum not in g_instNum_to_event_target:
        # some elements we don't care about, so we don't log at their
        # construction time; but later, e.g., when they become shadow
        # hosts, we start logging their byte ranges, because we were
        # thinking maybe shadow hosts can cause network requests
        return

    element = g_instNum_to_event_target[elemInstNum]
    assert isinstance(element, Element)

    assert start >= -1 and end >= -1
    # the start can only be set once
    assert element.byte_range_start is None or element.byte_range_start == start
    element.byte_range_start = start
    # the end can be updated, e.g., for inline script elements, which
    # contain child text nodes
    element.byte_range_end = end
    return




###### common element creation stuff

def _handle_new_element(elemClass,
                        # the following args are exactly those passed
                        # in by the log processor
                        log_event_info,
                        docInstNum, elemInstNum):

    docInstNum, elemInstNum = list(map(int, [docInstNum, elemInstNum]))
    _validate_instNum(elemInstNum)
    assert elemInstNum not in g_instNum_to_event_target


    # if we know for sure this is part of main html, then we should
    # just mark this element as part of the main doc html, and don't
    # add CreateElementActionEdge's.
    #
    # HOW know for sure this is part of main html? logically i believe
    # it means we are not executing any javascript
    if not is_executing_javascript():
        # if we are not inside a script scope, then we must be part of
        # the original html (right?); it's not enough to rely on
        # "createdByParser" because even if it's true, it can mean
        # "created by parser, while parsing html inserted by script,
        # e.g., by doc.write(), innerHtml, etc.")

        # assert docInstNum == g_main_doc.instNum

        doc = g_instNum_to_event_target[docInstNum]
        element = elemClass(elemInstNum, None, create_ts=log_event_info.ts)
        ContainingEdge(doc, element)
        pass
    else:
        element = elemClass(elemInstNum, current_important_scope(), create_ts=log_event_info.ts)
        CreateElementActionEdge(current_important_scope(), element, ts=log_event_info.ts)
        pass

    g_instNum_to_event_target[elemInstNum] = element

    return element

###### script elements stuff

# t=1, ts=    158.30, HTMLScriptElement.cpp :53, HTMLScriptElement(): ___ doc:8: new script elem:41 createdByParser= 1 alreadyStarted= 0 depParents= []

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': new script ' + _elem_pattern_str + ' '
    'createdByParser= (?P<createdByParser>\d+) alreadyStarted= (?P<alreadyStarted>\d+) depParents= .*$')
@_check_log_event_info(fileName='HTMLScriptElement.cpp', functionName='HTMLScriptElement()')
def _handle_wk_new_script_elem(log_event_info,
                                docInstNum, elemInstNum, createdByParser, alreadyStarted):
    element = _handle_new_element(ScriptElement,
                                  log_event_info,
                                  docInstNum, elemInstNum)
    createdByParser, alreadyStarted = list(
        map(int, [createdByParser, alreadyStarted]))
    createdByParser = _get_bool_from_int(createdByParser)
    alreadyStarted = _get_bool_from_int(alreadyStarted)
    element.alreadyStarted = alreadyStarted
    return

# t=1, ts=    158.32, HTMLScriptElement.cpp :104, parseAttribute(): ___ doc:8: script elem:41 src [...] completeURL [...]

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': script ' + _elem_pattern_str + ' '
    'src \[(?P<srcValue>.*)\] completeURL \[(?P<completeURL>.*)\]$')
@_check_log_event_info(fileName='HTMLScriptElement.cpp', functionName='parseAttribute()')
def _handle_wk_script_elem_src_attr(log_event_info,
                                    docInstNum, elemInstNum, srcValue, completeURL):
    elemInstNum = int(elemInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == ScriptElement
    element.src = srcValue
    element.completeURL = completeURL
    assert completeURL != _not_shown_url

    g_url_to_elements[completeURL].add(element)

    ts = log_event_info.ts

    if is_executing_javascript():
        try:
            if (type(outer_scope_at(0)) is _ParserPumpTokenizerScope):
                element.initial_resource_url_from_html = completeURL
                pass
            pass
        except:
            pass

        outer_scope = current_important_scope()
        SetResourceReferenceEdge(
            src=outer_scope, dst=element, ts=ts, completeURL=completeURL)
        pass
    else:
        element.initial_resource_url_from_html = completeURL
        pass

    return

# t=1, ts=    998.54, PendingScript.h :104, setElement(): ___ doc:8: HTMLScriptRunner hasParserBlockingScript= 1, elem:1036
@g_log_processor.register(
    r'^' + _doc_pattern_str + ': HTMLScriptRunner hasParserBlockingScript= (?P<hasParserBlockingScript>\d+), '
    + _elem_pattern_str)
@_check_log_event_info(fileName='PendingScript.h', functionName='setElement()')
def _handle_wk_script_elem_is_parser_blocking(log_event_info,
                                              docInstNum, hasParserBlockingScript, elemInstNum):
    if find_outer_scope(_ParserInsertScope):
        assert type(outer_scope_at(0)) is _ParserPumpTokenizerScope
        assert type(outer_scope_at(1)) is _ParserInsertScope
        if outer_scope_at(1).parsingFragment:
            # scripts inserted from fragments won't be executed
            return
        pass

    docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    hasParserBlockingScript = _get_bool_from_int(int(hasParserBlockingScript))
    assert hasParserBlockingScript

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) is ScriptElement
    element.is_parser_blocking = True

    # global g_parserBlockingScript
    # assert g_parserBlockingScript is None, '{}'.format(g_parserBlockingScript)
    # g_parserBlockingScript = element

    # logging.debug('setting elem "{}" as parser blocking script'.format(str(g_parserBlockingScript)))
    return

# t=1, ts=   1405.73, HTMLScriptRunner.cpp :155, executeParsingBlockingScript(): ___ scopeStart:1464910015283.046875: doc:8: begin
# t=1, ts=   1427.55, HTMLScriptRunner.cpp :155, executeParsingBlockingScript(): ___ scopeStart:1464910015283.046875: doc:8: done (dur= 21.817139)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _scope_action_pattern_str + '$',
    fileName='HTMLScriptRunner.cpp', functionName='executeParsingBlockingScript()')
@_check_log_event_info(fileName='HTMLScriptRunner.cpp', functionName='executeParsingBlockingScript()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_execute_parser_blocking_script_scope_action(log_event_info,
                                                           scopeStart, docInstNum, action):
    docInstNum = int(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    _check_event_target_instNum(docInstNum)

    scopeClass = ExecuteParserBlockingScriptScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done' or action == 'NOT':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=    612.66, ScriptLoader.cpp :174, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: begin
# t=1, ts=    612.67, ScriptLoader.cpp :194, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: forceAsync= 1
# t=1, ts=    612.69, ScriptLoader.cpp :222, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: forceAsync= 0
# t=1, ts=    612.70, ScriptLoader.cpp :251, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: it has source attribute, so go fetch it!
# .
# .
# .
# t=1, ts=    612.89, ScriptLoader.cpp :271, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: [willBeParserExecuted= 1] (parserInserted, has src attr, not async)
# t=1, ts=    612.91, ScriptLoader.cpp :174, prepareScript(): ___ scopeStart:1464455334096.098877: doc:8: prepare script elem:41: done
# t=1, ts=    612.92, HTMLScriptRunner.cpp :433, runScript(): ___ scopeStart:1464455334096.041992: doc:8: elem:41: done preparing script
# t=1, ts=    612.94, HTMLScriptRunner.cpp :456, runScript(): ___ scopeStart:1464455334096.041992: doc:8: elem:41: begin requesting parser blocking script
# t=1, ts=    612.95, PendingScript.h :104, setElement(): ___ doc:8: HTMLScriptRunner hasParserBlockingScript= 1, elem:41
# t=1, ts=    612.96, HTMLScriptRunner.cpp :458, runScript(): ___ scopeStart:1464455334096.041992: doc:8: elem:41: done requesting parser blocking script
# t=1, ts=    612.97, NestingLevelIncrementer.h :63, ~NestingLevelIncrementer(): ___ scopeStart:1464455334096.041992: doc:8: runScript(), scriptNestingLevel recursionLevel down to 0

class _ScriptLoaderPrepareScriptScope(UnimportantExecutionScope):
    def __init__(self, *args, scriptElement, **kwargs):
        super().__init__(*args, **kwargs)
        self.scriptElement = scriptElement
        pass

    def toString(self, *args, **kwargs):
        return super().toString(*args, **kwargs) + \
          ' elem:{elemInstNum}'.format(elemInstNum=self.scriptElement.instNum)

    def draw_get_label(self):
        return 'PrepScript'

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': prepare script ' + _elem_pattern_str + ': ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='ScriptLoader.cpp', functionName='prepareScript()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_script_loader_prepare_script_scope(log_event_info,
                                                  scopeStart, docInstNum, elemInstNum, action):
    docInstNum, elemInstNum = list(map(int, [docInstNum, elemInstNum]))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == ScriptElement

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _ScriptLoaderPrepareScriptScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, None, recursionLevel=1,
                           scopeStart=scopeStart, scriptElement=element)
        push_scope(scope)

        element.set_script_prepare_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=    980.76, ScriptLoader.cpp :261, prepareScript(): ___ scopeStart:1464455334464.163086: doc:8: prepare script elem:44: it has no source attribute, so not fetching it

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': prepare script ' + _elem_pattern_str + ': ' + \
    'it has no source attribute, so not fetching it$')
@_check_log_event_info(fileName='ScriptLoader.cpp', functionName='prepareScript()')
def _handle_wk_detect_script_has_no_src_attr(log_event_info,
                                             scopeStart, docInstNum, elemInstNum):
    docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    assert type(outer_scope_at(0)) is _ScriptLoaderPrepareScriptScope

    script = g_instNum_to_event_target[elemInstNum]
    assert type(script) is ScriptElement
    script.set_hasSrcAttr(False)

    return

# t=1, ts=    980.76, ScriptLoader.cpp :261, prepareScript(): ___ scopeStart:1464455334464.163086: doc:8: prepare script elem:44: it has source attribute, so go fetch it!

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': prepare script ' + _elem_pattern_str + ': ' + \
    'it has source attribute, so go fetch it!$')
@_check_log_event_info(fileName='ScriptLoader.cpp', functionName='prepareScript()')
def _handle_wk_detect_script_does_have_src_attr(log_event_info,
                                             scopeStart, docInstNum, elemInstNum):
    docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    assert type(outer_scope_at(0)) is _ScriptLoaderPrepareScriptScope

    script = g_instNum_to_event_target[elemInstNum]
    assert type(script) is ScriptElement
    script.set_hasSrcAttr(True)

    return


@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': prepare script ' + _elem_pattern_str + ': ' \
    '\[(?P<actions>.*)\] \((?P<reasons>.*)\)$')
@_check_log_event_info(fileName='ScriptLoader.cpp', functionName='prepareScript()')
def _handle_wk_script_loader_prepare_script_actions_and_reasons(log_event_info,
                                                                scopeStart, docInstNum, elemInstNum, actions, reasons):
    docInstNum, elemInstNum = list(map(int, [docInstNum, elemInstNum]))

    _check_event_target_instNum(docInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == ScriptElement

    assert type(outer_scope_at(0)) is _ScriptLoaderPrepareScriptScope

    for action in map(str.strip, actions.split(',')):
        if action == 'willExecuteWhenDocumentFinishedParsing= 1':
            assert element.willExecuteWhenDocumentFinishedParsing is None
            element.willExecuteWhenDocumentFinishedParsing = True
            pass
        elif action == 'willBeParserExecuted= 1':
            assert element.willBeParserExecuted is None
            element.willBeParserExecuted = True
            pass
        elif action == 'readyToBeParserExecuted= 1':
            assert element.readyToBeParserExecuted is None
            element.readyToBeParserExecuted = True
            pass
        elif action == 'willExecuteInOrder= 1':
            assert element.willExecuteInOrder is None
            element.willExecuteInOrder = True
            raise Exception('TODO')
            pass
        elif action == 'go execute it!':
            # the script runner will execute the script immediately
            # even if there are blocking stylesheets
            assert element.willBeParserExecuted is None
            element.set_shouldExecImmediately(True)
            pass
        elif action == 'queue for async execution':
            assert element.hasSrcAttr()
            element.queueForAsyncExecution = True
            pass
        else:
            raise Exception('unknown action "{}"'.format(action))
        pass

    for reason in map(str.strip, reasons.split(',')):
        if reason == 'parserInserted':
            assert element.parserInserted is None
            element.parserInserted = True
            pass
        elif reason == 'has src attr':
            assert element.hasSrcAttr()
            # element.set_hasSrcAttr(True)
            pass
        elif reason == 'no src attr':
            assert not element.hasSrcAttr()
            # element.set_hasSrcAttr(False)
            pass
        elif reason == 'defer':
            assert element.defer is None
            element.defer = True
            pass
        elif reason == 'not async':
            assert element.async is None
            element.async = False
            pass
        elif reason == 'rendering not ready':
            pass
        elif reason == '':
            # this is ok
            assert action == 'go execute it!'
            element.set_shouldExecImmediately(True)
            pass
        else:
            raise Exception('unexpected reason "{}"'.format(reason))
        pass

    return

# t=1, ts=    967.80, ScriptController.cpp :200, executeScriptAndReturnValue(): ___ scopeStart:1464455334451.238037: doc:8: script elem:41 url [http://use.typekit.net/zpy2xov.js]: begin
# t=1, ts=    972.09, ScriptController.cpp :206, executeScriptAndReturnValue(): ___ scopeStart:1464455334451.238037: doc:8: script elem:41 url [http://use.typekit.net/zpy2xov.js]: compile duration: 4.259033
# t=1, ts=    972.12, V8RecursionScope.h :79, V8RecursionScope(): ___ scopeStart:1464455334455.561035: enter scope at [V8ScriptRunner.cpp:187, runCompiledScript(): doc:8], recursionLevel up to 1
# t=1, ts=    980.38, V8RecursionScope.h :89, ~V8RecursionScope(): ___ scopeStart:1464455334455.561035: exit scope at [V8ScriptRunner.cpp:187, runCompiledScript(): doc:8], recursionLevel down to 0
# t=1, ts=    980.40, ScriptController.cpp :200, executeScriptAndReturnValue(): ___ scopeStart:1464455334451.238037: doc:8: script elem:41 url [http://use.typekit.net/zpy2xov.js]: done

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': script ' + _elem_pattern_str + ' url \[(?P<url>.*)\]: compile duration: ' + \
    '(?P<compileDuration>.*)$')
@_check_log_event_info(fileName='ScriptController.cpp', functionName='executeScriptAndReturnValue()')
def _handle_wk_script_compile_duration(log_event_info,
                                       scopeStart, docInstNum, elemInstNum, url, compileDuration):
    elemInstNum = int(elemInstNum)
    if elemInstNum:
        _check_event_target_instNum(elemInstNum)
        pass

    compileDuration = float(compileDuration)

    element = g_instNum_to_event_target[elemInstNum] if elemInstNum != 0 else None
    if type(element) is ScriptElement:
        assert element.compile_duration is None
        element.compile_duration = compileDuration
        pass
    else:
        assert (type(element) is IFrameElement) or elemInstNum == 0
        assert compileDuration < 1.0
        pass
    pass

# t=1, ts=   1660.00, ScriptController.cpp :200, executeScriptAndReturnValue(): ___ scopeStart:1469390592371.856934: doc:7: script elem:40 url [...]: begin
# t=1, ts=   1665.39, ScriptController.cpp :206, executeScriptAndReturnValue(): ___ scopeStart:1469390592371.856934: doc:7: script elem:40 url [...]: compile duration: 5.357910
# t=1, ts=   1675.53, ScriptController.cpp :200, executeScriptAndReturnValue(): ___ scopeStart:1469390592371.856934: doc:7: script elem:40 url [...]: done (dur= 15.524902)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + \
    ': script ' + _elem_pattern_str + \
    ' url \[(?P<url>.*)\]: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='ScriptController.cpp', functionName='executeScriptAndReturnValue()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_run_script_elem(log_event_info,
                               scopeStart, docInstNum, action, elemInstNum, url):
    elemInstNum = int(elemInstNum)
    if elemInstNum:
        _check_event_target_instNum(elemInstNum)
        pass

    # if elemInstNum == 40:
    #     pdb.set_trace()
    #     pass

    element = g_instNum_to_event_target[elemInstNum] if elemInstNum != 0 else None

    if elemInstNum == 0 or type(element) == IFrameElement:
        assert len(url) == 0
        scopeClass = _MinimalDummyScope
        pass
    else:
        assert type(element) == ScriptElement
        scopeClass = ScriptControllerRunScriptScope
        pass

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    if action == 'begin':
        scope = scopeClass(ts, event_no,
                           current_important_scope() if scopeClass == ScriptControllerRunScriptScope else None,
                           recursionLevel=1, scopeStart=scopeStart)
        if scopeClass == ScriptControllerRunScriptScope:
            element.set_script_execution_scope(scope)
            scope.scriptElement = element
            pass
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)

        if scopeClass != ScriptControllerRunScriptScope:
            assert scopeClass == _MinimalDummyScope
            assert scope.duration() < 0.5
            assert (scope.close_event_seq_no() - scope.open_event_seq_no()) == 4
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    pass

# t=1, ts=   5768.50, HTMLScriptRunner.cpp :437, runScript(): ___ scopeStart:1476569754480.495850: doc:7: elem:3761: will not be executed by parser

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _elem_pattern_str + ': will not be executed by parser$')
@_check_log_event_info(fileName='HTMLScriptRunner.cpp',
                       functionNames='runScript()')
def _handle_wk_parser_wont_execute_script(log_event_info,
                                          scopeStart, docInstNum, elemInstNum):
    docInstNum, elemInstNum = list(map(int, (docInstNum, elemInstNum)))

    element = g_instNum_to_event_target[elemInstNum]

    assert type(element) is ScriptElement

    element.will_not_be_executed = True

    return


# t=1, ts=     81.96, NestingLevelIncrementer.h :52, NestingLevelIncrementer(): ___ scopeStart:1464117100027.489990: doc:8: runScript(), scriptNestingLevel recursionLevel up to 1
# t=1, ts=     88.70, NestingLevelIncrementer.h :63, ~NestingLevelIncrementer(): ___ scopeStart:1464117100027.489990: doc:8: runScript(), scriptNestingLevel recursionLevel down to 0

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    '(?P<location>.*), scriptNestingLevel ' + \
    'recursionLevel (?P<action>[^ ]*) to (?P<recursionLevel>\d+)$')
@_check_log_event_info(fileName='NestingLevelIncrementer.h',
                       functionNames=('NestingLevelIncrementer()', '~NestingLevelIncrementer()'))
def _handle_wk_update_script_runner_nesting_level(log_event_info,
                                                  scopeStart, docInstNum, location, action, recursionLevel):
    docInstNum, recursionLevel = list(map(int, (docInstNum, recursionLevel)))

    assert location in ('runScript()', 'executePendingScriptAndDispatchEvent()'), location
    if action == 'up':
        g_script_runner.inc_scriptNestingLevel()
        pass
    elif action == 'down':
        g_script_runner.dec_scriptNestingLevel()
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    logging.debug('NEW script nesting level {}'.format(g_script_runner.scriptNestingLevel()))

    assert g_script_runner.scriptNestingLevel() == recursionLevel, '{} != {}'.format(
        g_script_runner.scriptNestingLevel(), recursionLevel)

    return

# t=1, ts=   1261.31, FontLoader.cpp :60, addFontToBeginLoading(): ___ doc:7: schedule loadPendingFonts 1-shot timer

# note that webkit logs the "schedule timer" line only if the timer is
# not already currently scheduled

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': schedule loadPendingFonts 1-shot timer$')
@_check_log_event_info(fileName='FontLoader.cpp', functionName='addFontToBeginLoading()')
def _handle_wk_font_loader_timer_scheduled(log_event_info,
                                           docInstNum):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    global g_scheduled_font_loader_timer
    assert g_scheduled_font_loader_timer is None
    g_scheduled_font_loader_timer = SchedulingEdgeWithTs(current_important_scope(), None, ts=ts)

    return

# t=1, ts=   1194.86, FontLoader.cpp :70, beginLoadTimerFired(): ___ scopeStart:1470279820801.031982: doc:7: loadPendingFonts 1-shot timer fired: begin
# t=1, ts=   1195.09, FontLoader.cpp :70, beginLoadTimerFired(): ___ scopeStart:1470279820801.031982: doc:7: loadPendingFonts 1-shot timer fired: done (dur= 0.221924)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'loadPendingFonts 1-shot timer fired: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='FontLoader.cpp', functionName='beginLoadTimerFired()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_loadPendingFonts_timer_fired(log_event_info,
                                            scopeStart, docInstNum, action):
    docInstNum = int(docInstNum)

    _validate_instNum(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = LoadPendingFontsTimerFiredScope

    if action == 'begin':
        global g_scheduled_font_loader_timer
        assert g_scheduled_font_loader_timer

        # timer fired should be a top-level scope
        assert not scope_stack_size(), \
          'unexpected current scope {}'.format(outer_scope_at(0))

        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart)
        push_scope(scope)

        g_scheduled_font_loader_timer.set_dst(scope)
        g_scheduled_font_loader_timer = None

        add_font_loader_timer_scope(scope)
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


###### dom timers stuff

# t=1, ts=    575.45, DOMTimer.cpp :116, DOMTimer(): ___ doc:8: timerID:1 created, interval 3000, singleShot= 1, scheduledAction:2

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': ' + _domtimer_pattern_str + ' created, ' \
    + 'interval (?P<interval>\d*), singleShot= (?P<singleShot>\d*), ' \
    + _scheduledAction_pattern_str + '$')
@_check_log_event_info(fileName='DOMTimer.cpp', functionName='DOMTimer()')
def _handle_wk_new_dom_timer(log_event_info,
                             docInstNum, timerID, interval, singleShot, scheduledActionInstNum):
    docInstNum, timerID, interval, singleShot, scheduledActionInstNum = list(
        map(int, (docInstNum, timerID, interval, singleShot, scheduledActionInstNum)))

    singleShot = _get_bool_from_int(singleShot)

    _validate_instNum(docInstNum)

    outer_scope = current_important_scope()
    # we expect dom timer can only be created when executing
    # javascript
    assert outer_scope and is_executing_javascript()

    timer = DOMTimer(timerID, interval, singleShot,
                     creator_scope=outer_scope, create_ts=log_event_info.ts)

    add_domTimer(docInstNum, timerID, timer)

    logging.debug('created timer {timerID}, current scope {scope}'.format(
        timerID=timerID, scope=outer_scope))

    pass


# t=1, ts=   1845.54, DOMTimer.cpp :89, removeByID(): ___ doc:8: timerID:11 removed

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': ' + _domtimer_pattern_str + ' removed$')
@_check_log_event_info(fileName='DOMTimer.cpp', functionName='removeByID()')
def _handle_wk_clear_dom_timer(log_event_info,
                             docInstNum, timerID):
    docInstNum, timerID = list(map(int, (docInstNum, timerID)))

    _validate_instNum(docInstNum)
    
    # we're seeing a bunch of "removeByID(): ___ doc:7: timerID:0
    # removed" on msn.com without seeing timerID:0 being created
    #
    # in ExecutionContext.cpp we see:
    #
    # if (timeoutID <= 0)
    #     return;
    # m_timeouts.remove(timeoutID);
    #
    # so, we can ignore if timer id <= 0

    if timerID <= 0:
        return

    timer = get_domTimer(docInstNum, timerID)

    outer_scope = current_important_scope()
    # we expect dom timer can only be cleared when executing
    # javascript
    assert outer_scope and is_executing_javascript()

    timer.clear_timer(current_important_scope(), ts=log_event_info.ts)

    pass

# t=1, ts=   1363.59, DOMTimer.cpp :151, fired(): ___ scopeStart:1464455334847.029053: doc:8: timerID:17 fired: begin

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _domtimer_pattern_str + ' fired: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='DOMTimer.cpp', functionName='fired()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_dom_timer_fired(log_event_info,
                               scopeStart, docInstNum, timerID, action):
    docInstNum, timerID = list(map(int, (docInstNum, timerID)))

    _validate_instNum(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    timer = get_domTimer(docInstNum, timerID)
    assert timer
    scopeClass = DOMTimerFiredScope

    if action == 'begin':
        # timer fired should be a top-level scope
        assert not scope_stack_size(), \
          'unexpected current scope {}'.format(outer_scope_at(0))

        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart,
                           timerID=timerID)
        push_scope(scope)

        timer.add_timer_fired_scope(scope)
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


# t=1, ts=   2726.70, HTMLIFrameElement.cpp :52, HTMLIFrameElement(): ___ doc:7: new iframe elem:3544 createdByParser= 0 depParents= []

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': new iframe ' + _elem_pattern_str + ' '
    'createdByParser= (?P<createdByParser>\d+) depParents= .*$')
@_check_log_event_info(fileName='HTMLIFrameElement.cpp', functionName='HTMLIFrameElement()')
def _handle_wk_new_iframe_elem(log_event_info,
                               docInstNum, elemInstNum, createdByParser):
    _handle_new_element(IFrameElement,
                        log_event_info,
                        docInstNum, elemInstNum)
    return

###### link elements stuff

# t=1, ts=     81.13, HTMLLinkElement.cpp :162, HTMLLinkElement(): ___ doc:8: new link elem:40 createdByParser= 1

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': new link ' + _elem_pattern_str + ' '
    'createdByParser= (?P<createdByParser>\d+)$')
@_check_log_event_info(fileName='HTMLLinkElement.cpp', functionName='HTMLLinkElement()')
def _handle_wk_new_link_elem(log_event_info,
                             docInstNum, elemInstNum, createdByParser):
    _handle_new_element(LinkElement,
                        log_event_info,
                        docInstNum, elemInstNum)
    return

# t=1, ts=     71.97, HTMLLinkElement.cpp :205, parseAttribute(): ___ doc:8: link elem:17 href [/favicon.ie9.ico] completeURL [http://www.cnn.com/favicon.ie9.ico]

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': link ' + _elem_pattern_str + ' '
    'href \[(?P<hrefValue>.*)\] completeURL \[(?P<completeURL>.*)\]$')
@_check_log_event_info(fileName='HTMLLinkElement.cpp', functionName='parseAttribute()')
def _handle_wk_link_elem_href_attr(log_event_info,
                                   docInstNum, elemInstNum, hrefValue, completeURL):
    elemInstNum = int(elemInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == LinkElement
    element.href = hrefValue
    element.completeURL = completeURL
    assert completeURL != _not_shown_url

    g_url_to_elements[completeURL].add(element)

    ts = log_event_info.ts

    if is_executing_javascript():
        outer_scope = current_important_scope()
        SetResourceReferenceEdge(
            src=outer_scope, dst=element, ts=ts, completeURL=completeURL)
        pass
    else:
        element.initial_resource_url_from_html = completeURL
        pass

    return

# t=1, ts=     81.14, HTMLLinkElement.cpp :194, parseAttribute(): ___ doc:8: link elem:40 rel [dns-prefetch]

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': link ' + _elem_pattern_str + ' '
    'rel \[(?P<relValue>.*)\]$')
@_check_log_event_info(fileName='HTMLLinkElement.cpp', functionName='parseAttribute()')
def _handle_wk_link_elem_rel_attr(log_event_info,
                                  docInstNum, elemInstNum, relValue):
    if relValue == 'dns-prefetch':
        # for now we don't care about dns-prefetch
        return
    elif relValue == 'subresource':
        raise Exception('todo')
        pass

    if True:
        elemInstNum = int(elemInstNum)
        _check_event_target_instNum(elemInstNum)

        element = g_instNum_to_event_target[elemInstNum]
        assert type(element) == LinkElement
        element.rel = relValue
        pass

    return

# t=1, ts=   1060.06, StyleEngine.cpp :250, addPendingSheet(): ___ doc:8: new number of blocking stylesheets: 1 (elem:27 being added)
# t=1, ts=    428.60, StyleEngine.cpp :274, removePendingSheet(): ___ doc:8: new number of blocking stylesheets: 2 (elem:35 being removed)

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': new number of blocking stylesheets: '
    '(?P<numSheets>\d+) \(' + _elem_pattern_str + ' being (?P<action>[^ ]*)\)')
@_check_log_event_info(fileName='StyleEngine.cpp',
                       functionNames=('addPendingSheet()', 'removePendingSheet()'))
def _handle_wk_blocking_stylesheet_action(log_event_info,
                                          docInstNum, numSheets, elemInstNum, action):
    docInstNum, numSheets, elemInstNum = list(map(int, (docInstNum, numSheets, elemInstNum)))
    _check_event_target_instNum(elemInstNum)

    assert action in ('added', 'removed')

    global g_current_num_blocking_sheets
    g_current_num_blocking_sheets += 1 if action == 'added' else -1
    assert g_current_num_blocking_sheets >= 0

    assert numSheets == g_current_num_blocking_sheets

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == LinkElement
    element.is_blocking_stylesheet = True

    return

###### image element stuff

# t=1, ts=   1422.71, HTMLImageElement.cpp :120, HTMLImageElement(): ___ doc:8: new image elem:77 createdByParser= 1 depParents= [url= [http://www.berkeley.edu/] isParser= 1 set by= HTMLImageElement.cpp :108 at ts=   1422.71]

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': new image ' + _elem_pattern_str + ' '
    'createdByParser= (?P<createdByParser>\d+) depParents= .*$')
@_check_log_event_info(fileName='HTMLImageElement.cpp', functionName='HTMLImageElement()')
def _handle_wk_new_image_elem(log_event_info,
                              docInstNum, elemInstNum, createdByParser):
    _handle_new_element(ImageElement,
                        log_event_info,
                        docInstNum, elemInstNum)
    return

# t=1, ts=   1422.88, HTMLImageElement.cpp :710, selectSourceURL(): ___ doc:8: img elem:80 src [http://www.berkeley.edu/images/uploads/logo-ucberkeley.png] completeURL [http://www.berkeley.edu/images/uploads/logo-ucberkeley.png] depParent []

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': img ' + _elem_pattern_str + ' '
    'src \[(?P<srcValue>.*)\] completeURL \[(?P<completeURL>.*)\] depParent.*$')
@_check_log_event_info(fileName='HTMLImageElement.cpp', functionName='selectSourceURL()')
def _handle_wk_image_elem_src_attr(log_event_info,
                                   docInstNum, elemInstNum, srcValue, completeURL):
    elemInstNum = int(elemInstNum)
    _check_event_target_instNum(elemInstNum)

    element = g_instNum_to_event_target[elemInstNum]
    assert type(element) == ImageElement
    element.src = srcValue
    element.completeURL = completeURL
    assert completeURL != _not_shown_url

    g_url_to_elements[completeURL].add(element)

    ts = log_event_info.ts

    if is_executing_javascript():
        outer_scope = current_important_scope()
        SetResourceReferenceEdge(
            src=outer_scope, dst=element, ts=ts, completeURL=completeURL)
        if element.instNum != 687:
            # pdb.set_trace()
            pass
        pass
    else:
        element.initial_resource_url_from_html = completeURL
        pass

    return


########

# t=1, ts=    830.75, ElementShadow.cpp :152, addShadowRoot(): ___ scopeStart:1470679839602.885010: doc:7: add shadow host elem:87: begin
# t=1, ts=    830.76, ElementShadow.cpp :219, setNeedsDistributionRecalc(): ___ scopeStart:1470679839602.899170: doc:7: shadow host elem:87 maybe calls markAncestorsWithChildNeedsDistributionRecalc: begin
# t=1, ts=    830.77, ElementShadow.cpp :219, setNeedsDistributionRecalc(): ___ scopeStart:1470679839602.899170: doc:7: shadow host elem:87 maybe calls markAncestorsWithChildNeedsDistributionRecalc: done (dur= 0.009033)
# t=1, ts=    830.78, ElementShadow.cpp :152, addShadowRoot(): ___ scopeStart:1470679839602.885010: doc:7: add shadow host elem:87: done (dur= 0.036865)

# elements that are shadow hosts. we don't care about their specific
# type (i.e., tag) because for now we only care about these elements
# because processing them might schedule a render update, and we need
# an Element to be able to create a scheduling edge.
g_shadow_host_elems = {}

class _AddShadowRootElementScope(UnimportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.element = None
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': add shadow host ' + \
    _elem_pattern_str + ': ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='ElementShadow.cpp', functionName='addShadowRoot()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_add_shadow_host_scope_action(log_event_info,
                                            scopeStart, docInstNum, elemInstNum, action):
    # at this time we only care about shadow hosts that are part of
    # main html cuz processing them might schedule render tree
    # updates, and html processing depends on byte offsets. if instead
    # we're in these scopes, any render scheduling will be part of the
    # scope
    if is_executing_javascript():
        return
    else:
        assert find_outer_scope(_ParserPumpTokenizerScope)
        pass

    docInstNum, elemInstNum = list(map(int, [docInstNum, elemInstNum]))

    scopeClass = _AddShadowRootElementScope

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    if action == 'begin':
        # assert elemInstNum not in g_instNum_to_event_target
        # element = Element(elemInstNum, tag='_shadow_host_',
        #                   creator_scope=current_important_scope(), create_ts=ts)
        # g_instNum_to_event_target[elemInstNum] = element
        element = _handle_new_element(ShadowHostElement, log_event_info, docInstNum, elemInstNum)

        scope = scopeClass(ts, event_no, None,
                           recursionLevel=1, scopeStart=scopeStart)
        push_scope(scope)
        scope.element = element
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

########

# t=1, ts=   1634.67, Document.cpp :1830, scheduleRenderTreeUpdate(): ___ doc:8: render tree update is scheduled

@g_log_processor.register(
    r'^' + _doc_pattern_str + ': render tree update is scheduled$')
@_check_log_event_info(fileName='Document.cpp', functionName='scheduleRenderTreeUpdate()')
def _handle_wk_render_tree_update_scheduled(log_event_info,
                                            docInstNum):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No
    docInstNum = int(docInstNum)

    if docInstNum != g_main_doc.instNum:
        # if it's not for the main doc, just ignore it
        return

    global g_scheduled_render_tree_update
    if g_scheduled_render_tree_update:
        # if there is already a scheduling operation, we just do
        # nothing here
        return

    # if we're in a v8 scope (including operations like setting
    # attribute), then we just let this edge be scheduled by the v8
    # scope as a scheduling edge with ts. else if we in an "add shadow
    # root" scope, then we say the element schedules the update
    if (not find_outer_scope(V8Scope)) and (find_outer_scope(_AddShadowRootElementScope)):
        outerscope = outer_scope_at(0)
        assert type(outerscope) is _AddShadowRootElementScope
        g_scheduled_render_tree_update = SchedulingEdge(outerscope.element, None)
        pass
    else:
        g_scheduled_render_tree_update = RenderUpdateSchedulingEdge(current_important_scope(), None, ts=ts)
        pass

    return

# t=1, ts=   1081.17, Document.cpp :1991, updateRenderTree(): ___ scopeStart:1464455334564.610107: doc:8: update render tree: begin
# t=1, ts=   1132.49, Document.cpp :1991, updateRenderTree(): ___ scopeStart:1464455334564.610107: doc:8: update render tree: done

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': update render tree: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='Document.cpp', functionName='updateRenderTree()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_update_render_tree_transition(log_event_info,
                                             scopeStart, docInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    docInstNum = int(docInstNum)
    if docInstNum != g_main_doc.instNum:
        # if not for main doc, just ignore
        return

    scopeClass = RenderTreeUpdateScope
    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart)
        push_scope(scope)

        add_render_tree_update_scope(scope)
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=   1324.27, RenderView.cpp :229, layout(): ___ scopeStart:1470275352280.589111: doc:7: renderview layout: begin
# t=1, ts=   1327.90, RenderView.cpp :229, layout(): ___ scopeStart:1470275352280.589111: doc:7: renderview layout: done (dur= 3.623047)

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'renderview layout: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='RenderView.cpp', functionName='layout()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_renderview_layout_scope_action(log_event_info,
                                              scopeStart, docInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = RenderViewLayoutScope
    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart)
        push_scope(scope)

        # add_layout_scope(scope)
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return



# t=1, ts=   2381.78, LocalDOMWindow.cpp :1648, dispatchEvent(): ___ scopeStart:1469390593093.643066: window:1, event [load]: whole document: begin
# t=1, ts=   2385.76, LocalDOMWindow.cpp :1648, dispatchEvent(): ___ scopeStart:1469390593093.643066: window:1, event [load]: whole document: done (dur= 3.977051)

class _DocMiscEventScope(EventTargetEventScopeBase, ImportantExecutionScope):
    # for now we don't handle these scopes, so we don't want to do
    # interesting things/take too long
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass

    def close(self, ts, event_seq_no, scopeStart=None):
        super().close(ts, event_seq_no, scopeStart=scopeStart)
        assert self.duration() < 3.0
        # assert (self.close_event_seq_no() - self.open_event_seq_no()) == 1
        pass

    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _window_pattern_str + ', '
    'event \[(?P<eventName>.*)\]: whole document: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='LocalDOMWindow.cpp', functionName='dispatchEvent()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_dom_window_dispatch_event(log_event_info,
                                         scopeStart, windowInstNum, eventName, action):
    windowInstNum = int(windowInstNum)

    ##
    ## the document's "load" event that we are interested are not
    ## fired by the document, but rather by the window (the document
    ## fires the "readystatechange" event first (after setting its
    ## state to "complete"), then the window fires this "load" event).
    ##
    ## we don't really model the window, so we just manually add this
    ## event to the main doc
    ##

    if windowInstNum != 1:
        # handle only the main window
        return

    _check_event_target_instNum(windowInstNum)

    # _check_event_target_instNum(docInstNum)

    # doc = g_instNum_to_event_target[docInstNum]
    # assert type(doc) == Document and doc.instNum == docInstNum

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    if eventName == 'load':
        scopeClass = DocOnLoadEventScope
        pass
    else:
        scopeClass = _DocMiscEventScope
        pass

    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(), recursionLevel=1,
                           scopeStart=scopeStart, eventName=eventName,
                           # using windowInstNum, not docInstNum
                           eventTargetInstNum=windowInstNum)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)

        if eventName != 'load':
            # if the event is anything besides "load", for now we
            # expect that it doesn't do anything interesting
            assert (ts - scope.open_ts()) < 5.0

            # make sure no interesting edges were added to the scope
            # or its inner scopes
            if len(scope.out_edges(includeInnerScopes=True)) > 0:
                logging.warn('window:{windowInstNum} has a handling scope for '
                             'event "{eventName}" that does something potentially '
                             'interesting, but we are IGNORING it'.format(
                                 windowInstNum=windowInstNum, eventName=eventName))
                pass
            pass
        else:
            g_main_doc.add_dom_event_handling_scope(eventName, scope)
            pass

        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return



# t=1, ts=   1050.28, EventTarget.cpp :348, fireEventListeners(): ___ scopeStart:1464455334533.715088: doc:8: eventtarget:48 event [load], notify 1 event listeners, node:48: begin

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _event_target_pattern_str + ' ' \
    'event \[(?P<eventName>.*)\], notify (?P<numListeners>\d*) event listeners, '
    'node:(?P<nodeInstNum>\d*): ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='EventTarget.cpp', functionName='fireEventListeners()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_event_target_invoking_listeners(log_event_info,
                                               scopeStart, docInstNum, eventTargetInstNum, eventName, action,
                                               numListeners, nodeInstNum):
    docInstNum, eventTargetInstNum, numListeners, nodeInstNum = list(
        map(int, (docInstNum, eventTargetInstNum, numListeners, nodeInstNum)))
    assert eventTargetInstNum == nodeInstNum
    assert numListeners > 0

    try:
        _check_event_target_instNum(eventTargetInstNum)
        pass
    except:
        return

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = EventTargetInvokingListenersScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           recursionLevel=1, scopeStart=scopeStart,
                           eventName=eventName, eventTargetInstNum=eventTargetInstNum)

        if eventName == 'readystatechange':
            outer_scope = outer_scope_at(0)
            assert type(outer_scope) is DOMReadyStateChangeEventScope
            assert eventTargetInstNum == docInstNum
            scope.readyState = outer_scope.readyState
            pass

        eventtarget = g_instNum_to_event_target[eventTargetInstNum]
        assert isinstance(eventtarget, EventTarget)
        eventtarget.add_dom_event_handling_scope(eventName, scope)

        push_scope(scope)

        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return


# t=1, ts=   2766.20, Document.cpp :4976, finishedParsing(): ___ scopeStart:1469993871562.762939: doc:7: finished parsing: begin
# t=1, ts=   3239.95, Document.cpp :4976, finishedParsing(): ___ scopeStart:1469993871562.762939: doc:7: finished parsing: done (dur= 473.741943)

class DocFinishedParsingScope(ImportantExecutionScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': finished parsing: ' + \
    _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='Document.cpp', functionName='finishedParsing()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_doc_finished_parsing_scope_action(log_event_info,
                                                 scopeStart, docInstNum, action):
    docInstNum = int(docInstNum)

    _check_event_target_instNum(docInstNum)

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = DocFinishedParsingScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, current_important_scope(),
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        if (docInstNum == g_main_doc.instNum):
            # this must be a top-level scope
            num_outer_scopes = scope_stack_size()
            if num_outer_scopes == 1:
                outer_scope = outer_scope_at(0)
                assert type(outer_scope) is FetchFinishScope
                # the resource could be a script: upon finish loading
                # the script, it gets to run, and after running
                # script, while still in the fetch finish scope, the
                # parser/script runner resumes parsing, which can
                # bring us here to DocFinishedParsingScope
                resInstNum = outer_scope.resInstNum
                resource = g_fetched_instNum_to_resource[resInstNum]
                assert (outer_scope.resInstNum == g_main_resource.instNum) or \
                      resource.type == ResourceType.Script, '{} {} {}'.format(
                        outer_scope.resInstNum, g_main_resource.instNum, resource.type)
                pass
            else:
                assert num_outer_scopes == 0
                pass
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    pass


# t=1, ts=   1050.29, EventTarget.cpp :424, fireEventListeners(): ___ scopeStart:1464455334533.727783: doc:8: eventtarget:48: tell event listener:2 to handle event [load]: begin

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + _event_target_pattern_str + ': ' \
    'tell event listener:(?P<eventListenerInstNum>\d+) '
    'to handle event \[(?P<eventName>.*)\]: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='EventTarget.cpp', functionName='fireEventListeners()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_event_target_invoking_one_listener(log_event_info,
                                                  scopeStart, docInstNum, eventTargetInstNum, action,
                                                  eventListenerInstNum, eventName):
    docInstNum, eventTargetInstNum, eventListenerInstNum = list(
        map(int, (docInstNum, eventTargetInstNum, eventListenerInstNum)))

    try:
        _check_event_target_instNum(eventTargetInstNum)
        pass
    except KeyError:
        # we don't know about the event, but we've seen this with
        # "eventtarget:2280 event [submit], notify 1 event listeners,"
        # on bankofamerica.com. so we can make a special case for this
        assert eventName == 'submit'
        return
        pass

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = EventTargetInvokingOneListenerScope

    if action == 'begin':
        # assert the outer scope
        if eventName not in ('message', 'deviceorientation', 'progress'):
            outer_scope = outer_scope_at(0)
            assert type(outer_scope) in (EventTargetInvokingListenersScope, FetchFinishScope,
                                        DocOnLoadEventScope, _DocMiscEventScope, DocFinishedParsingScope,
                                        DOMReadyStateChangeEventScope), \
            'unexpected outer scope: {}'.format(outer_scope)
            if type(outer_scope) == EventTargetInvokingListenersScope:
                assert outer_scope.eventName == eventName, '{} {}'.format(outer_scope.eventName, eventName)
                assert outer_scope.eventTargetInstNum == eventTargetInstNum
                pass
            outer_scope = None
            pass

        scope = scopeClass(ts, event_no, None,
                           recursionLevel=1, scopeStart=scopeStart,
                           eventName=eventName, eventTargetInstNum=eventTargetInstNum)

        if eventName == 'readystatechange':
            outer_scope = outer_scope_at(0)
            if type(outer_scope) is DOMReadyStateChangeEventScope:
                assert type(g_instNum_to_event_target[eventTargetInstNum]) is XMLHttpRequest
                pass
            else:
                assert type(outer_scope) is EventTargetInvokingListenersScope
                pass
            scope.readyState = outer_scope.readyState
            pass

        scope.set_to_be_pruned(g_instNum_to_event_target[eventTargetInstNum].to_be_pruned())

        push_scope(scope)
        pass
    elif action == 'done':
        # the earlier scope must NOT have ended
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.eventName == eventName
        assert scope.eventTargetInstNum == eventTargetInstNum
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

########

# t=1, ts=1463431925250.05, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [create promise: begin, no-op resolver]
# t=1, ts=1463432750999.14, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [create promise:   done, no-op resolver]

class _CreatePromiseWithOobExecutorScope(UnimportantExecutionScope):
    # this class is only used so that we know the promise to be
    # constructed will have an out-of-band executor scope, i.g., the
    # executor scope does not happen while the promise is being
    # constructed
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'create promise: (  )?(?P<action>[^ ]*), no-op resolver' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_create_promise_with_oob_executor_scope_action(log_event_info, who,
                                                             action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _CreatePromiseWithOobExecutorScope

    if action == 'begin':
        # right now we expect no-op-resolver promises are only created
        # when creating font promise resolver
        #
        # OR it's fine if it's an inner scope of a v8scope
        assert isinstance(outer_scope_at(0),
                          (_CreatingFontPromiseResolverScope, V8Scope))
        # giving None for outer_scope so that the outer scope doesn't
        # add the new scope as an inner
        scope = scopeClass(ts, event_no, outer_scope=None, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass and not scope.outer_scope()
        scope.close(ts, event_no)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    709.54, FontFaceSet.cpp :527, load(): ___ scopeStart:1463434318188.190918: doc:8: fontfaceset:9: promise:1026: begin calling executor
# t=1, ts=    709.68, FontFaceSet.cpp :533, load(): ___ scopeStart:1463434318188.190918: doc:8: fontfaceset:9: promise:1026: done calling executor

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _fontfaceset_pattern_str + ': ' + _promise_pattern_str + ': ' + \
    '(?P<action>[^ ]*) calling executor$')
@_check_log_event_info(fileName='FontFaceSet.cpp', functionName='load()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_fontfaceset_promise_executor_scope_action(log_event_info,
                                                         scopeStart, docInstNum, fontfacesetInstNum,
                                                         promiseInstNum, action):
    docInstNum, fontfacesetInstNum, promiseInstNum = list(
        map(int, (docInstNum, fontfacesetInstNum, promiseInstNum)))

    if _ignore_promiseInstNums(promiseInstNum):
        return

    _check_event_target_instNum(docInstNum)
    _validate_instNum(fontfacesetInstNum)

    promise = g_promises.get(promiseInstNum, None)
    assert promise

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = FontFaceSetLoadPromiseExecutorScope

    if action == 'begin':
        # we do NOT wanna make this scope an inner of the
        # current_important_scope(), because we will later attach it to the
        # promise that has been created with the no-op executor
        scope = scopeClass(ts, event_no,
                           outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1,
                           promiseInstNum=promiseInstNum)
        push_scope(scope)

        logging.debug('setting executor scope {}'.format(str(scope)))
        promise.set_execute_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.promiseInstNum == promiseInstNum
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

# t=1, ts=    704.90, FontFaceSet.cpp :514, load(): ___ scopeStart:1463434318183.549805: doc:8: fontfaceset:9 begin creating fontpromiseresolver
# t=1, ts=    704.90, FontFaceSet.cpp :514, load(): ___ scopeStart:1463434318183.549805: doc:8: fontfaceset:9 done creating fontpromiseresolver

class _CreatingFontPromiseResolverScope(UnimportantExecutionScope):
    # only used to make sure we create the no-op-executor promise only
    # during this scope
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _fontfaceset_pattern_str + ' (?P<action>[^ ]*) creating fontpromiseresolver$')
@_check_log_event_info(fileName='FontFaceSet.cpp', functionName='load()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_fontfaceset_creating_promise_resolve_scope_action(log_event_info,
                                                                 scopeStart, docInstNum, fontfacesetInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _CreatingFontPromiseResolverScope

    if action == 'begin':
        # giving None to the scope constructor so that the outer scope
        # doesn't add the new scope as an inner
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass and not scope.outer_scope()
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    705.25, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [...]: [ctor promise:1002: begin]
# t=1, ts=    705.34, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [...]: [ctor promise:1002:   done]

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'ctor ' + _promise_pattern_str + ': (  )?(?P<action>[^ ]*)' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_create_promise_scope_action(log_event_info, who,
                                           promiseInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum = int(promiseInstNum)

    if _ignore_promiseInstNums(promiseInstNum):
        return

    scopeClass = CreatePromiseScope

    if action == 'begin':
        assert is_executing_javascript()

        createdWithOobExecutor = (type(outer_scope_at(0)) is _CreatePromiseWithOobExecutorScope)
        if createdWithOobExecutor:
            assert outer_scope_at(0).open_event_seq_no() == (event_no - 1)
            pass

        assert promiseInstNum not in g_promises
        g_promises[promiseInstNum] = Promise(
            instNum=promiseInstNum, create_ts=ts,
            creator_scope=current_important_scope())

        scope = scopeClass(ts, event_no,
                           outer_scope=current_important_scope(),
                           promiseInstNum=promiseInstNum,
                           createdWithOobExecutor=createdWithOobExecutor)
        push_scope(scope)

        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.promiseInstNum == promiseInstNum
        scope.close(ts, event_no)

        assert promiseInstNum in g_promises, promiseInstNum

        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    705.27, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [...]: [ctor promise:1002: begin calling executor]
# t=1, ts=    705.32, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [...]: [ctor promise:1002:   done calling executor]

class _PromiseNoopExecutorScope(ExecutePromiseScope):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        pass
    pass

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'ctor ' + _promise_pattern_str + ': (  )?(?P<action>[^ ]*) calling executor' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_calling_promise_executor_scope_action(log_event_info, who,
                                                     promiseInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum = int(promiseInstNum)

    if _ignore_promiseInstNums(promiseInstNum):
        return

    assert promiseInstNum in g_promises
    promise = g_promises[promiseInstNum]

    if action == 'begin':
        assert type(outer_scope_at(0)) is CreatePromiseScope, outer_scope_at(0)

        if type(outer_scope_at(1)) is _CreatePromiseWithOobExecutorScope:
            scopeClass = _PromiseNoopExecutorScope
            pass
        else:
            scopeClass = ExecutePromiseScope
            pass

        scope = scopeClass(ts, event_no, outer_scope=None,
                           promiseInstNum=promiseInstNum)
        push_scope(scope)

        if scopeClass is ExecutePromiseScope:
            promise.set_execute_scope(scope)
            pass
        else:
            assert scopeClass is _PromiseNoopExecutorScope
            # NOT setting the executor scope
            pass
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is ExecutePromiseScope or type(scope) is _PromiseNoopExecutorScope
        scope.close(ts, event_no)
        assert scope.promiseInstNum == promiseInstNum
        if type(scope) is _PromiseNoopExecutorScope:
            # make sure nothing is done during no-op executor scope
            assert scope.open_event_seq_no() == (event_no - 1)
            # we don't have any use for this scope
            del scope
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    664.62, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:13: begin]
# t=1, ts=    664.64, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:13 -> promise:15: begin]
# t=1, ts=    664.66, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:13 -> promise:15: done]
# t=1, ts=    664.67, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:13:   done]

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'then ' + _promise_pattern_str + ': (  )?(?P<action>[^ ]*)?' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_thenning_promise_scope_action(log_event_info, who,
                                             promiseInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum = int(promiseInstNum)

    if _ignore_promiseInstNums(promiseInstNum):
        return

    assert promiseInstNum in g_promises, promiseInstNum

    scopeClass = _ThenPromiseScope

    if action == 'begin':
        scope = scopeClass(ts, event_no,
                           outer_scope=None,
                           promiseInstNum=promiseInstNum)
        push_scope(scope)

        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.promiseInstNum == promiseInstNum
        scope.close(ts, event_no)
        # we are expecting thenning a promise just creates a chaining
        # promise which takes up 2 lines in between
        assert (scope.open_event_seq_no() + 3) == event_no
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    664.62, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:13: begin]
# t=1, ts=    664.64, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:13 -> promise:15: begin]
# t=1, ts=    664.66, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:13 -> promise:15: done]
# t=1, ts=    664.67, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:13:   done]

class _ThenPromiseScope(UnimportantExecutionScope):
    def __init__(self, *args, promiseInstNum, **kwargs):
        super().__init__(*args, **kwargs)
        self.promiseInstNum = promiseInstNum
        pass
    pass

class _ChainPromiseScope(UnimportantExecutionScope):
    def __init__(self, *args, promiseInstNum, promiseInstNum2, **kwargs):
        super().__init__(*args, **kwargs)
        self.promiseInstNum = promiseInstNum
        self.promiseInstNum2 = promiseInstNum2
        pass
    pass

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'chain ' + _promise_pattern_str + ' -> ' + _promise2_pattern_str + ': (  )?(?P<action>[^ ]*)?' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_chaining_promise_scope_action(log_event_info, who,
                                             promiseInstNum, promiseInstNum2, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum, promiseInstNum2 = list(map(int, (promiseInstNum, promiseInstNum2)))

    if _ignore_promiseInstNums((promiseInstNum, promiseInstNum2)):
        return

    assert promiseInstNum in g_promises

    scopeClass = _ChainPromiseScope

    if action == 'begin':
        assert type(outer_scope_at(0)) is _ThenPromiseScope
        assert outer_scope_at(0).open_event_seq_no() == (event_no - 1)
        scope = scopeClass(ts, event_no, outer_scope=None,
                           promiseInstNum=promiseInstNum, promiseInstNum2=promiseInstNum2)
        push_scope(scope)

        # promiseInstNum2 is created while in the chaining scope of
        # promiseInstNum
        assert promiseInstNum2 not in g_promises
        promise = Promise(
            instNum=promiseInstNum2, create_ts=ts, creator_scope=current_important_scope())
        g_promises[promiseInstNum2] = promise

        g_promises[promiseInstNum].add_chain_promise(promise)

        pass
    elif action == 'done':
        assert promiseInstNum2 in g_promises

        scope = pop_scope()
        assert type(scope) == scopeClass
        scope.close(ts, event_no)
        assert scope.promiseInstNum == promiseInstNum and scope.promiseInstNum2 == promiseInstNum2
        # we are expecting nothing happens in between
        assert (scope.open_event_seq_no() + 1) == event_no

        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

# t=1, ts=    663.44, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [race promise:6: begin]
# t=1, ts=    663.48, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [race promise:6:   racer promise:5]
# t=1, ts=    663.53, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:5: begin]
# t=1, ts=    663.58, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:5 -> promise:7: begin]
# t=1, ts=    663.61, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:5 -> promise:7: done]
# t=1, ts=    663.64, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:5:   done]
# t=1, ts=    663.67, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [race promise:6:   racer promise:2]
# t=1, ts=    663.70, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:2: begin]
# t=1, ts=    663.72, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:2 -> promise:8: begin]
# t=1, ts=    663.73, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [chain promise:2 -> promise:8: done]
# t=1, ts=    663.74, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [then promise:2:   done]
# t=1, ts=    663.76, V8Initializer.cpp :186, myLoggingInMainThread(): ___ my js log [http://use.typekit.net/zpy2xov.js:29]: [race promise:6:   done]

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'race ' + _promise_pattern_str + ': (  )?(?P<action>[^ ]*)?' + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_create_race_promise_scope_action(log_event_info, who,
                                                promiseInstNum, action):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum = int(promiseInstNum)

    if _ignore_promiseInstNums(promiseInstNum):
        return

    scopeClass = CreateRacePromiseScope

    if action == 'begin':
        outer_scope = current_important_scope()
        assert promiseInstNum not in g_promises, promiseInstNum

        g_promises[promiseInstNum] = RacePromise(
            instNum=promiseInstNum, create_ts=ts, creator_scope=outer_scope)

        scope = scopeClass(ts, event_no, outer_scope=None,
                           promiseInstNum=promiseInstNum)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and scope.promiseInstNum == promiseInstNum
        scope.close(ts, event_no)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))
    return

@g_log_processor.register(
    r'^' + _my_js_log_pattern_str + ': \[' + \
    'race ' + _promise_pattern_str + ':   racer ' + _promise2_pattern_str + \
    '\]$')
@_check_log_event_info(fileName='V8Initializer.cpp', functionName='myLoggingInMainThread()')
def _handle_wk_add_racer_promise(log_event_info, who,
                                 promiseInstNum, promiseInstNum2):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    promiseInstNum, promiseInstNum2 = list(map(int, (promiseInstNum, promiseInstNum2)))

    if _ignore_promiseInstNums((promiseInstNum, promiseInstNum2)):
        return

    promise = g_promises[promiseInstNum]
    assert type(promise) is RacePromise

    racer = g_promises[promiseInstNum2]
    assert type(racer) is Promise

    promise.add_racer(racer)
    return

###########

# t=1, ts=   2195.59, markup.cpp :928, createFragmentForInnerOuterHTML(): ___ scopeStart:1469390592907.445801: doc:7: create fragment:1094, contextElement:1093: begin
# t=1, ts=   2195.79, markup.cpp :928, createFragmentForInnerOuterHTML(): ___ scopeStart:1469390592907.445801: doc:7: create fragment:1094, contextElement:1093: done (dur= 0.199951)

class _CreatingFragmentScope(UnimportantExecutionScope):
    def __init__(self, *args, fragmentInstNum, **kwargs):
        super().__init__(*args, **kwargs)
        self.fragmentInstNum = fragmentInstNum
        pass
    pass

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    'create fragment:(?P<fragmentInstNum>.*), contextElement:.*: ' + \
    _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='markup.cpp', functionName='createFragmentForInnerOuterHTML()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_creating_fragment_scope_action(log_event_info,
                                              scopeStart, docInstNum, action, fragmentInstNum):
    fragmentInstNum = int(fragmentInstNum)
    assert fragmentInstNum not in g_instNum_to_event_target

    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    scopeClass = _CreatingFragmentScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, None,
                           scopeStart=scopeStart, recursionLevel=1,
                           fragmentInstNum=fragmentInstNum)
        push_scope(scope)
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) == scopeClass and fragmentInstNum == scope.fragmentInstNum
        scope.close(ts, event_no, scopeStart=scopeStart)
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

#############

# t=1, ts=   1839.19, HTMLDocumentParser.cpp :682, pumpTokenizer(): ___ scopeStart:1474708879298.477783: doc:7: parser:2: EndOfFile token after 140149 parsed bytes

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _parser_pattern_str + ': EndOfFile token after (?P<size>.*) parsed bytes$')
@_check_log_event_info(fileName='HTMLDocumentParser.cpp',
                       functionName='pumpTokenizer()')
def _handle_wk_main_html_uncompressed_size(log_event_info,
                                           scopeStart, docInstNum, parserInstNum, size):

    docInstNum, parserInstNum = list(map(int, [docInstNum, parserInstNum]))

    if (docInstNum == g_main_doc.instNum) or (parserInstNum == 2):
        # if either is true, then both must be true
        assert (docInstNum == g_main_doc.instNum) and (parserInstNum == 2)
        # it's the main html
        assert g_main_doc.uncompressed_html_size is None
        g_main_doc.uncompressed_html_size = int(size)
        assert g_main_doc.uncompressed_html_size > 0
        pass

    return

#############

# t=1, ts=   1312.38, XMLHttpRequest.cpp :463, dispatchReadyStateChangeEvent(): ___ scopeStart:1464718156977.909180: doc:8: xmlhttprequest:1197, state= [OPENED]: begin
# t=1, ts=   1312.39, XMLHttpRequest.cpp :463, dispatchReadyStateChangeEvent(): ___ scopeStart:1464718156977.909180: doc:8: xmlhttprequest:1197, state= [OPENED]: done

@g_log_processor.register(
    r'^' + _scopeStart_pattern_str + ': ' + _doc_pattern_str + ': ' + \
    _xhr_pattern_str + ', state= \[(?P<state>.*)\]: ' + _scope_action_pattern_str + '$')
@_check_log_event_info(fileName='XMLHttpRequest.cpp', functionName='dispatchReadyStateChangeEvent()')
@_check_pushed_scope_has_scopeStart
def _handle_wk_xhr_dispatch_readystatechange_event_scope_action(log_event_info,
                                                                scopeStart, docInstNum, xhrInstNum, action, state):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    docInstNum, xhrInstNum = list(map(int, (docInstNum, xhrInstNum)))

    xhr = g_instNum_to_event_target[xhrInstNum]
    assert type(xhr) is XMLHttpRequest

    eventName = 'readystatechange'

    scopeClass = DOMReadyStateChangeEventScope

    if action == 'begin':
        scope = scopeClass(ts, event_no, outer_scope=None,
                           scopeStart=scopeStart, recursionLevel=1,
                           eventName=eventName, eventTargetInstNum=docInstNum,
                           readyState=state)
        push_scope(scope)
        scope.set_to_be_pruned(xhr.to_be_pruned())
        pass
    elif action == 'done':
        scope = pop_scope()
        assert type(scope) is scopeClass
        scope.close(ts, event_no, scopeStart=scopeStart)
        if scope.readyState != 'DONE':
            # if the ready state is anything besides DONE, for now we
            # expect that it doesn't do anything interesting
            # assert (scope.open_event_seq_no() + 1) == event_no
            assert (ts - scope.open_ts()) < 2.0

            # make sure no interesting edges were added to the scope
            # or its inner scopes
            assert not scope.out_edges(includeInnerScopes=True)
            pass
        else:
            eventName += '_DONE'
            xhr.add_dom_event_handling_scope(eventName, scope)
            pass
        pass
    else:
        raise Exception('unexpected action "{}"'.format(action))

    return

#############

# [ts=1474708877543.38 http_stream_parser.cc :300] SendRequest(): ,,,, nlid:8, res:1, outboundSize= 333

@g_log_processor.register(
    r'^' + _netlog_id_pattern_str + ', ' + _res_pattern_str \
    + ', outboundSize= (?P<outboundSize>.*)$')
@_check_log_event_info(fileName='http_stream_parser.cc', functionName='SendRequest()')
def _handle_chrome_resource_outboundsize(log_event_info,
                                         nlid, resInstNum, outboundSize):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    nlid = int(nlid)
    assert nlid > 0

    outboundSize = int(outboundSize)
    assert outboundSize > 0, outboundSize

    resInstNum = int(resInstNum)

    if resInstNum == 0:
        assert nlid in g_unknown_resource_fetches
        resource = g_unknown_resource_fetches[nlid]
        pass
    else:
        _check_resInstNum(resInstNum)
        resource = g_fetched_instNum_to_resource[resInstNum]
        pass

    resource.append_outboundSize(outboundSize)

    return

# [ts=   6036.31 http_stream_parser.cc :528] DoSendBodyComplete(): ,,,, nlid:302, res:26, additional upload bytes= 747

@g_log_processor.register(
    r'^' + _netlog_id_pattern_str + ', ' + _res_pattern_str \
    + ', additional upload bytes= (?P<moreOutboundSize>.*)$')
@_check_log_event_info(fileName='http_stream_parser.cc', functionName='DoSendBodyComplete()')
def _handle_chrome_resource_additional_upload_bytes(log_event_info,
                                                    nlid, resInstNum, moreOutboundSize):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    nlid = int(nlid)
    assert nlid > 0

    moreOutboundSize = int(moreOutboundSize)
    assert moreOutboundSize >= 0, moreOutboundSize

    resInstNum = int(resInstNum)

    if resInstNum == 0:
        assert nlid in g_unknown_resource_fetches
        resource = g_unknown_resource_fetches[nlid]
        pass
    else:
        _check_resInstNum(resInstNum)
        resource = g_fetched_instNum_to_resource[resInstNum]
        pass

    resource.increment_current_outboundSize(moreOutboundSize)

    return


# for some redirects, e.g., with res:18 in
# samples/alibaba/alibaba-10152016.log.txt.bz2, we don't see the
# HttpStreamParser for the second (all subsequent?) requests, so we
# will instead rely on HttpNetworkTransaction, which seems to always
# know about downstream byte count but never upstream byte count. so
# we still have to rely on HttpStreamParser for the original upstream
# byte count, and then assume subsequent upstream byte counts are the
# same
#

# [ts=   1173.25 http_network_transaction.cc :156] ~HttpNetworkTransaction(): ,,,, nlid:200, res:18 totalRecvBytes= 0 stream's total_received_bytes_= 421 DONE 

@g_log_processor.register(
    r'^' + _netlog_id_pattern_str + ', ' + _res_pattern_str \
    + ' totalRecvBytes= (?P<inboundSize>.*) stream\'s total_received_bytes_= (?P<streamInboundSize>.*) DONE$')
@_check_log_event_info(fileName='http_network_transaction.cc',
                       functionName='~HttpNetworkTransaction()')
def _handle_chrome_resource_inboundsize_from_http_network_transaction(log_event_info,
                                        nlid, resInstNum, inboundSize, streamInboundSize):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    nlid = int(nlid)
    assert nlid > 0

    inboundSize, streamInboundSize = list(map(int, (inboundSize, streamInboundSize)))
    assert inboundSize == 0, inboundSize

    resInstNum = int(resInstNum)

    if resInstNum == 0:
        assert nlid in g_unknown_resource_fetches
        resource = g_unknown_resource_fetches[nlid]
        pass
    else:
        _check_resInstNum(resInstNum)
        resource = g_fetched_instNum_to_resource[resInstNum]
        pass

    resource.append_inboundSize(streamInboundSize)

    return

# [ts=     41.30 http_stream_parser.cc :205] ~HttpStreamParser(): ,,,, nlid:8, res:1, received_bytes_= 30716

@g_log_processor.register(
    r'^' + _netlog_id_pattern_str + ', ' + _res_pattern_str \
    + ', received_bytes_= (?P<inboundSize>.*)$')
@_check_log_event_info(fileName='http_stream_parser.cc', functionName='~HttpStreamParser()')
def _handle_chrome_resource_inboundsize(log_event_info,
                                        nlid, resInstNum, inboundSize):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    nlid = int(nlid)
    assert nlid > 0

    inboundSize = int(inboundSize)
    assert inboundSize > 0, inboundSize

    resInstNum = int(resInstNum)

    if resInstNum == 0:
        assert nlid in g_unknown_resource_fetches
        resource = g_unknown_resource_fetches[nlid]
        pass
    else:
        _check_resInstNum(resInstNum)
        resource = g_fetched_instNum_to_resource[resInstNum]
        pass

    # we only assert the size is similar (*) as the one at the end of
    # the array, which is assumed to have been added by
    # ~HttpNetworkTransaction
    #
    # we do NOT add to the list of inboundSizes
    #
    # (*) we have seen the transaction and stream parser disagree:
    #
    # [~HttpNetworkTransaction(): ,,,, nlid:152, res:16 totalRecvBytes= 0 stream's total_received_bytes_= 962 DONE
    # [~HttpStreamParser(): ,,,, nlid:152, res:16, received_bytes_= 1004
    #
    # update: 10152016: hmm maybe the difference is due to
    # compression/ssl ? with http://www.google.com/ have seen the main
    # resource (res:1) redirect response reported as 607 and 838 bytes
    # by network transaction and parser respectively. manually update
    # the sizes in the log to avoid the assert here
    #
    # UPDATE: 10/26/2016: i have seen this happen with 301 redirect
    # responses: the stream parser's "received_bytes_" is reporting
    # the total size of response meta and html body (e.g., the simple
    # "this page has moved permanently to <insert url>" page), while
    # network transaction's "total_received_bytes_" is reporting the
    # size of the html body only --->>> so, we will use the value
    # reported by stream parser. ALSO, i have confirmed with a simple
    # tiny test page that if the two values agree, then they are
    # reporting the size of the whole response: meta + body

    assert (len(resource._inboundSizes) > 0)
    if inboundSize != resource._inboundSizes[-1]:
        logging.warn(
            'http_network_transaction and http_stream_parser disagree '
            'about the size of the response for res:{}: {} != {}. we believe http_stream_parser'.format(
                resInstNum, resource._inboundSizes[-1], inboundSize))
        assert resource._inboundSizes[-1] < inboundSize
        resource._inboundSizes[-1] = inboundSize
        pass

    return


# [ts=    564.34 http_network_transaction.cc :202] Start(): ,,,, nlid:275, res:0, method= [] url= [] starts

@g_log_processor.register(
    r'^' + _netlog_id_pattern_str + ', ' + _res_pattern_str \
    + ', method= \[(?P<method>.+)\] url= \[(?P<url>.+)\] starts$')
@_check_log_event_info(fileName='http_network_transaction.cc', functionName='Start()')
def _handle_chrome_starts_http_transaction(log_event_info,
                                           nlid, resInstNum, method, url):
    ts = log_event_info.ts
    event_no = log_event_info.log_event_No

    nlid = int(nlid)
    assert nlid > 0

    resInstNum = int(resInstNum)
    if resInstNum == 0:
        resource = Resource(instNum=0, url=url, create_ts=ts,
                            isDataURL=False, creator_scope=None, type_=ResourceType.Unknown)
        assert nlid not in g_unknown_resource_fetches
        g_unknown_resource_fetches[nlid] = resource

        resource.starts_fetching(ts=ts, starter_scope=None, method=method, priority=None)

        pass
    else:
        _check_resInstNum(resInstNum)
        resource = g_fetched_instNum_to_resource[resInstNum]
        pass

    d = {'url': url,
         'method': method,
         'priority': 3,
         }
    resource._request_chain.append(d)

    return

#############################################

def _write_set_resource_ref_edge(edge, cmds, output_elements, output_resources):
    elemInstNum = edge.dst().instNum
    if elemInstNum in output_elements:
        # if we're not interested in this element, then
        # ignore this edge

        # figure out which resInstNum the url refers to
        completeURL = edge.completeURL
        referenced_resInstNum = None
        for resInstNum, resource in g_fetched_url_to_resources[completeURL].items():
            if resource._request_chain[0]['method'] == 'GET':
                # this assert fails on aws.amazon.com where multiple
                # resources have the same url. perhaps resource
                # fetcher removes the resource from its memory cache,
                # causing the same url to require a new resource to be
                # loaded
                assert referenced_resInstNum is None
                referenced_resInstNum = resInstNum
                pass
            pass
        assert referenced_resInstNum in output_resources
        cmds.append('set_elem_res({elemInstNum}, {resInstNum});'.format(
            elemInstNum=elemInstNum, resInstNum=referenced_resInstNum))
        pass

def _write_render_update_sched_edge(edge, cmds, used_scopes):
    render_update_scope = edge.dst()
    assert render_update_scope is not None
    scope_id = render_update_scope.scope_id()
    if scope_id in used_scopes:
        cmds.append('sched_render_update_scope({scope_id});'.format(
            scope_id=scope_id))
        pass
    else:
        # it should be an inner scope of some outer scope
        # that is already part of used_scopes, then we'd
        # be fine because the outer scope can "take over"
        # the things this scope does
        ok = False
        for outer_scope in render_update_scope.outer_scopes_to_root():
            if outer_scope.scope_id() in used_scopes:
                # our parent is already in used_scopes, so we can
                # remove ourselves
                ok = True
                break
            pass
        if not ok:
            pdb.set_trace()
            raise Exception('render tree update scope {} not in "used_scopes"'.format(
                str(render_update_scope)))
        pass
    pass

def _write_model(outfile):

    ### things that we need to include in the model:
    ###
    ### * fetched resources
    ###
    ### * relevant elements: script, image, link elements because they
    ### can cause/refer to resources. body elements because the
    ### browser won't attempt any rendering if the body element is not
    ### yet found
    ###
    ### * xmlhttprequest as well, cuz they can generate resources
    ###
    ### * scopes: we only include the, for lack of better word (?),
    ### fundamental scopes. what i mean is this, for example, say
    ### there are two blocking stylesheet resources, then whichever
    ### resource that finishes loading later will have its FetchFinish
    ### scope cause run the script. so FetchFinish is NOT a
    ### fundatamental scope. this distinction is PERHAPS
    ### related/similar to the important/unimportant scopes
    ###
    ### - ScriptControllerRunScriptScope
    ###
    ### - RenderTreeUpdateScope (ONLY if it's a global scope, i.e.,
    ### not an inner scope of some other scope)
    ###
    ###

    # the scopes that are useful for us. map from scope id to
    # ExecutionScope object
    used_scopes = {}

    orig_used_hostnames = set()
    
    ## add to it the relevant global/top-level scopes, e.g., when main
    ## doc finishes parsing, the global render tree update scopes

    # it's possible for the doc's 'load' event to be contained within,
    # i.e., inner scope of, the 'DOMContentLoaded' scope (seen this on
    # ebay.com), so we need to not include such inner scopes like with
    # other scopes

    main_doc_scope_id_to_event_name = {}
    event_names = set()
    for eventName, scope in g_main_doc.dom_event_handling_scopes():
        # logging.error('eventname: {}'.format(eventName))
        if (not eventName in ('DOMContentLoaded', 'readystatechange_complete', 'load')):
            # for main doc there can be custom events like
            # "AdFuelCreated" on cnn.com. we don't want to handle
            # these
            continue

        assert not eventName in event_names, \
            'event {} fires multiple times'.format(eventName)

        scope_id = scope.scope_id()
        assert scope_id not in main_doc_scope_id_to_event_name
        main_doc_scope_id_to_event_name[scope_id] = eventName

        assert scope_id not in used_scopes
        used_scopes[scope_id] = scope
        pass

    for scope in g_render_tree_update_scopes:
        assert scope.scope_id() not in used_scopes
        used_scopes[scope.scope_id()] = scope
        pass

    ##
    ## output the fetched resources
    ##

    # map key is resource instNum
    output_resources = {}

    for url, resInstNum_to_Resource in g_fetched_url_to_resources.items():
        for resInstNum, resource in resInstNum_to_Resource.items():
            assert resInstNum == resource.instNum

            output_resource = {}

            if not resource._request_chain:
                continue

            output_resource['type'] = resource.get_type_shortname()

            # "part_of_page_loaded_check" means this resource should
            # finish loading (either success or error) before the
            # document/page is considered finished loading, i.e., the
            # "load" DOM event
            output_resource['part_of_page_loaded_check'] = resource.contributes_to_req_count

            # take care of the request chain
            output_resource['req_chain'] = []
            http_req_chain = output_resource['req_chain']

            # this assert can happen in cases where we browse
            # "abc.com" but get redirected to "www.abc.com" but the
            # redirect mechanism did not go through the code paths
            # that we are aware of... should be able to modify the log
            # file to remove the first request
            assert len(resource._request_chain) == len(resource._outboundSizes) == len(resource._inboundSizes), \
              'res:{} numReqs= {} numOutboundSizes= {} numInboundSizes= {}'.format(
                  resource.instNum, len(resource._request_chain),
                  len(resource._outboundSizes), len(resource._inboundSizes))
            for i in range(len(resource._request_chain)):
                assert type(resource._request_chain[i]) is dict

                chain_entry = {}

                parsed = urlparse(resource._request_chain[i]['url'])
                hostname = parsed.hostname
                assert (hostname is not None) and len(hostname) > 0
                port = parsed.port
                if port is None:
                    if parsed.scheme == 'http':
                        port = 80
                        pass
                    elif parsed.scheme == 'https':
                        port = 443
                        pass
                    pass

                orig_used_hostnames.add(hostname)

                # chain_entry['scheme'] = parsed.scheme
                chain_entry['host'] = hostname
                chain_entry['port'] = port
                chain_entry['method'] = resource._request_chain[i]['method']
                chain_entry['priority'] = resource._request_chain[i]['priority']
                # webkit has 5 priorities: very low = 0, low = 1,
                # medium = 3, high = 4, very high = 5
                if chain_entry['priority'] is None:
                    chain_entry['priority'] = 3
                    pass
                else:
                    assert type(chain_entry['priority']) is int
                    assert 0 <= chain_entry['priority'] <= 5
                    pass

                chain_entry['req_total_size'] = resource._outboundSizes[i]

                ## we don't have separate info about response headers
                ## vs body, just the total size, so we just use a
                ## fixed 200 for the headers, and the remaining bytes
                ## for the response body... though some cases,
                ## response total is less than 200 bytes (e.g., an
                ## OPTIONS response)

                resp_meta_size = min(200, resource._inboundSizes[i])
                chain_entry['resp_meta_size'] = resp_meta_size
                chain_entry['resp_body_size'] = (resource._inboundSizes[i] - resp_meta_size)
                assert chain_entry['resp_meta_size'] >= 0
                assert chain_entry['resp_body_size'] >= 0

                http_req_chain.append(chain_entry)
                pass

            # handle specific aspects of different resource types
            if type(resource) is StyleSheetResource:
                # exactly one of parse_duration and parse_scope is non-Null
                if resource.parse_duration:
                    assert not resource.parse_scope
                    output_resource['parse_dur_ms'] = resource.parse_duration
                    pass
                elif resource.parse_scope:
                    assert not resource.parse_duration
                    scope_id = resource.parse_scope.scope_id()
                    output_resource['parse_scope_id'] = scope_id
                    assert scope_id not in used_scopes
                    used_scopes[scope_id] = resource.parse_scope
                    del scope_id
                    pass
                else:
                    raise Exception('css res:{} has no parse duration or scope'.format(resInstNum))
                pass

            assert resInstNum not in output_resources
            output_resources[resInstNum] = output_resource
            del output_resource

            pass

        pass

    ##
    ## handling elements
    ##
    ## here, we only take care of the "static" aspects of elements,
    ## such as their end-byte-offsets in the main html, and in
    ## particular their original references to resources, i.e., the
    ## "src" that the main html contains.
    ##
    ## their src attributes can be changed by scripts later on, but we
    ## will have the scopes do that
    ##
    ## now, a non-empty "src" attribute results in the element's
    ## pointing to/referencing a URL, but our
    ## g_fetched_url_to_resources can contain multiple resources with
    ## the same URL. however, currently we assume that ONLY ONE of
    ## those multiple resources for the same url uses the GET http
    ## method, and that will be the one we make the element point to
    ## originally
    ##

    output_elements = {}

    # list of (end-byte-offset, elementInstNum) tuples. 
    main_html_elements = []

    for element in [et for et in g_instNum_to_event_target.values() if isinstance(et, Element)]:

        if element.tag not in ('body', 'img', 'link', 'script'):
            continue

        output_element = {}
        output_element['tag'] = element.tag

        if element.tag == 'link':
            # for now only care about stylesheet ones
            if element.rel != 'stylesheet':
                del output_element
                continue
            output_element['rel'] = element.rel
            output_element['is_blocking_css'] = element.is_blocking_stylesheet
            pass

        elif element.tag == 'script':
            if element.alreadyStarted or (element.script_execution_scope() is None):
                # we assume this is a script that never ran, and so we
                # can just leave it off the page model
                assert (element.script_prepare_scope is None) or (element.script_prepare_scope.duration() < 5.0)
                assert element.willBeParserExecuted is None
                assert element.willExecuteWhenDocumentFinishedParsing is None
                assert element.readyToBeParserExecuted is None
                assert element.willExecuteInOrder is None

                del output_element
                continue

            output_element['exec_immediately'] = element.shouldExecImmediately()
            if element.shouldExecImmediately():
                assert not element.hasSrcAttr()
                assert element.initial_resource_url_from_html is None
                pass
            # output_element['async'] = (element.async is True)
            # output_element['defer'] = (element.defer is True)
            # assert not output_element['async'], 'TODO'
            # assert not output_element['defer'], 'TODO'

            output_element['asyncExec'] = bool(element.queueForAsyncExecution)
            if bool(element.willExecuteInOrder):
                assert element.queueForAsyncExecution
                raise Exception('TODO')
                pass

            assert not bool(element.willExecuteWhenDocumentFinishedParsing), 'TODO'
            assert not bool(element.willExecuteInOrder), 'TODO'

            output_element['is_parser_blocking'] = element.is_parser_blocking
            if element.is_parser_blocking:
                assert not (element.queueForAsyncExecution)
                assert not (element.willExecuteInOrder)
                pass

            # we don't need separate compile duration, because the run
            # scope, which should be the
            # ScriptControllerRunScriptScope, already contains the
            # compilation time

            # output_element['compile_dur_ms'] = element.compile_duration
            # assert element.compile_duration is not None

            run_scope = element.script_execution_scope()
            assert type(run_scope) is ScriptControllerRunScriptScope

            run_scope_id = run_scope.scope_id()
            output_element['run_scope_id'] = run_scope_id

            assert run_scope_id not in used_scopes
            used_scopes[run_scope_id] = element.script_execution_scope()
            pass

        # this is the byte offset of the element's closing tag in the
        # MAIN html.... this can be NONE if the element is created by
        # script, not part of main html, etc.
        if element.byte_range_end:
            # output_element['end_byte_offset'] = element.byte_range_end
            main_html_elements.append((element.byte_range_end, element.instNum))
            pass

        initial_url = element.initial_resource_url_from_html
        if (initial_url in g_fetched_url_to_resources) and (initial_url != 'about:blank'):
            initial_referenced_resInstNum = None
            for resInstNum, resource in g_fetched_url_to_resources[initial_url].items():
                assert resource._request_chain, initial_url
                if resource._request_chain[0]['method'] == 'GET':
                    assert initial_referenced_resInstNum is None
                    initial_referenced_resInstNum = resInstNum
                    pass
                pass
            # the html can contain a ref to a resource (e.g., "src")
            # attribute, but it might not result in any fetches, due
            # to policy, etc.
            if initial_referenced_resInstNum:
                assert initial_referenced_resInstNum in output_resources
                output_element['initial_resInstNum'] = initial_referenced_resInstNum
                pass
            pass

        # write the dom events handling scope ids
        #
        # event listeners can be added from html markup (e.g., "<img
        # ... onload="func()">"). they can also dynamically by scripts
        # (e.g., via "element.addEventListener(...)" at any time.
        #
        # for now, we don't distinguish them.
        #
        #
        event_handling_scopes = []
        event_names = set()
        for eventName, scope in element.dom_event_handling_scopes():

            ## an element can fire the same event multiple times, e.g,
            ## every time javascript modifies the element's "src"
            ## attribute to point to a diff resource, the element is
            ## essentially reloading, so when the resource is finished
            ## downloading (or might be already loaded, e.g., due to
            ## being preloaded), then the element will fire the "load"
            ## event again
            #
            # for now, we don't support such scenarios, so we assert
            # that each event name/type occurs at most once
            assert not eventName in event_names


            event_handling_scopes.append((eventName, scope.scope_id()))

            assert scope.scope_id() not in used_scopes
            used_scopes[scope.scope_id()] = scope
            pass
        if event_handling_scopes:
            output_element['event_handling_scopes'] = event_handling_scopes
            pass

        assert element.instNum not in output_elements
        output_elements[element.instNum] = output_element
        del output_element

        pass

    ##
    ## take care of the dom timers
    ##
    ## dom timers can only be created by javascript code
    ##
    ## BUT NOTE THAT!!!  currently our design means the creator scope
    ## is the V8Scope, but we will want the v8scope's parent/outer
    ## scope, up to something that can link us to the rest of the
    ## page, such as a dom handling event, such as "DOMContentLoaded"
    ## firing event of the main page, or the "run_scope" of a script
    ## (for which we currently use the ScriptControllerRunScriptScope)
    ##
    ## this means we have to traverse the creator scope up, in order
    ## to find a scope that is in "used_scopes"

    output_timers = {}
    timer_creator_scopes = set()

    for timerID, timer in g_domTimers.items():
        # first, is this timer interesting? it is not interesting if,
        # say, its fired scopes take minimal total time, and don't
        # create any edge

        # logging.warning('creator scope {}'.format(timer.creator_scope))
        if timer.creator_scope.to_be_pruned() or timer.to_be_pruned():
            continue

        total_fired_scopes_time = sum(map(lambda scope: scope.duration(),
                                          timer.timer_fired_scopes()))
        total_fired_scopes_edges = sum(
            map(lambda scope: scope.count_out_edges(includeInnerScopes=True),
                timer.timer_fired_scopes()))
        if (total_fired_scopes_edges == 0) and (total_fired_scopes_time < 5.0):
            continue

        timer_creator_scopes.add(timer.creator_scope)

        output_timer = {}

        output_timer['singleShot'] = (timer.singleShot is True)
        output_timer['interval_ms'] = timer.interval
        assert type(timer.interval) is int
        assert timer.interval > 0

        fired_scope_ids = []
        for scope in timer.timer_fired_scopes():
            # timer fired scopes MUST be top-level scopes, i.e., have
            # no "outer" scopes
            assert len(scope.outer_scopes_to_root()) == 0

            scope_id = scope.scope_id()
            fired_scope_ids.append(scope_id)

            assert scope_id not in used_scopes
            used_scopes[scope_id] = scope
            pass

        output_timer['fired_scope_ids'] = sorted(fired_scope_ids)
        output_timers[timerID] = output_timer
        del output_timer
        pass

    ##
    ## take care of the xmlhttprequests
    ##

    output_xhrs = {}

    # set of scope ids of scopes that create xhr's
    xhr_creator_scopes = set()

    for xhrInstNum, xhr in g_xhrs.items():
        output_xhr = {}

        if xhr.creator_scope.to_be_pruned() or xhr.to_be_pruned():
            continue

        import copy
        # do the request chain
        if xhr.resource_chain:
            output_xhr['res_chain'] = copy.copy(xhr.resource_chain)
            pass
        
        # FOR NOW expect only the readystatechange_DONE (i.e., our
        # made-up name for the readystatechange event where the state
        # is DONE, instead of other states like HEADERS_RECEIVED or
        # LOADING, are interesting
        event_handling_scopes = []
        for eventName, scope in xhr.dom_event_handling_scopes():
            event_handling_scopes.append((eventName, scope.scope_id()))

            assert scope.scope_id() not in used_scopes
            used_scopes[scope.scope_id()] = scope
            pass
        if event_handling_scopes:
            assert len(event_handling_scopes) == 1 # for now
            assert event_handling_scopes[0][0] == 'readystatechange_DONE' # for now
            output_xhr['event_handling_scopes'] = event_handling_scopes
            assert len(output_xhr['res_chain']) > 0
            pass

        if output_xhr:
            # include it only if it's not empty
            output_xhrs[xhrInstNum] = output_xhr

            # deal with the creator scope
            assert xhr.creator_scope is not None
            xhr_creator_scopes.add(xhr.creator_scope)

            pass
        del output_xhr
        pass

    # perhaps check that all the scopes that create xhr's are in
    # "used_scopes"

    
    ##
    ## handle the main document
    ##
    ## the main_html_elements contains byte offsets withint the
    ## UNCOMPRESSED html, but the main resource response is almost
    ## surely compressed, so we have to scale/adjust the elements'
    ## byte offsets
    ##
    ## for now we use a simple scheme of just scaling them by the
    ## ratio: float(main_resource_resp_body_size) /
    ## main_html_uncompressed_size
    ##
    ##

    main_resource_instNum = g_main_resource.instNum
    assert main_resource_instNum in output_resources

    main_resource_body_size = output_resources[main_resource_instNum]['req_chain'][-1]['resp_body_size']
    assert main_resource_body_size < g_main_doc.uncompressed_html_size

    scale_ratio = float(main_resource_body_size) / float(g_main_doc.uncompressed_html_size)
    main_html_elements = list(map(lambda pair: [int(pair[0] * scale_ratio), pair[1]],
                                  main_html_elements))
    main_html_elements.sort(key=lambda pair: pair[0])

    # just make sure the elements are really sorted in ascending order
    # of offsets
    for i in range(len(main_html_elements) - 1):
        assert main_html_elements[i][0] <= main_html_elements[i+1][0]
        pass
    assert main_html_elements[-1][0] <= main_resource_body_size


    ## make sure we don't have dangling timers and xhrs, i.e., we can
    ## reach every timer/xhr, i.e., their creator scopes are one of
    ## the scopes we know about, or their inner scopes

    for creator_scopes in [timer_creator_scopes, xhr_creator_scopes]:
        for scope in creator_scopes:
            if scope.scope_id() not in used_scopes:
                # it's not in the used_scopes, so check its outer
                for outer_scope in scope.outer_scopes_to_root():
                    if outer_scope.scope_id() in used_scopes:
                        # good
                        break
                    pass
                else:
                    raise Exception('we cannot link creator scope {scope} '
                                    'to the rest of the model'.format(scope=scope))
                pass
            pass
        pass

    ##
    ## TODO: double-check that it makes sense for us to do the
    ## following:
    ##
    ## go through all the used_scopes. and remove any that has an
    ## outer scope that is already in "used_scopes" because the outer
    ## scope will absorb activities of all its inner scopes
    ##
    ##

    used_scope_ids = set(used_scopes.keys())

    del scope # to prevent mistakenly using "scope" from earlier code
    for used_scope_id in used_scope_ids:
        scope = used_scopes[used_scope_id]
        for outer_scope in scope.outer_scopes_to_root():
            if outer_scope.scope_id() in used_scopes:
                # our parent is already in used_scopes, so we can
                # remove ourselves
                del used_scopes[used_scope_id]
                logging.info('deleting scope:{}'.format(used_scope_id))

                if used_scope_id in main_doc_scope_id_to_event_name:
                    logging.info('   which is main doc event handling scope for "{}"'.format(
                        main_doc_scope_id_to_event_name[used_scope_id]))
                    del main_doc_scope_id_to_event_name[used_scope_id]
                    pass
                pass
            else:
                pass
            pass
        pass


    ##
    ## take care of the used scopes...
    ##
    ## for each scope, it might contain inner scopes that do
    ## interesting things. for example, a DOM event handling scopes
    ## will have one or more inner V8Scopes, and the v8 scopes create
    ## timers, starts fetches, etc.
    ##
    ## therefore, each scope will "absorb" all those edges from its
    ## inner scopes
    ##

    # map from scope id to angelscript code
    output_scopes = {}

    for scope_id, scope in used_scopes.items():

        if scope.to_be_pruned():
            continue

        # collect all of the scope's relevant out edges
        outedges = []
        for edge in scope.out_edges(includeInnerScopes=True):
            if isinstance(edge, (CreateElementActionEdge,
                                     RenderUpdateSchedulingEdge,
                                     CreateDOMTimerEdge,
                                     ClearDOMTimerEdge,
                                     SetResourceReferenceEdge,
                                     CreateXHREdge,
                                     FetchSchedulingEdge,
                                     )):
                outedges.append(edge)

                # make sure that the inner scope is NOT part of
                # "used_scopes" because that would mean the inner
                # scope might get executed later (or maybe already),
                # resulting in duplication of these edges
                direct_src = edge.src()
                if isinstance(direct_src, ExecutionScope) and (direct_src is not scope):
                    assert direct_src.scope_id() not in used_scopes
                    pass
                pass
            pass

        # pdb.set_trace()

        # sort the edges by ts
        outedges.sort(key=lambda edge: edge.ts())
        # just double check
        for i in range(len(outedges) - 1):
            assert outedges[i].ts() <= outedges[i+1].ts()
            pass

        ####### start loop through out edges #####

        previous_ts = scope.open_ts()
        cmds = []
        for edge in outedges:
            edge_ts = edge.ts()
            sleep_amt = edge_ts - previous_ts
            previous_ts = edge_ts
            assert sleep_amt >= 0
            if sleep_amt > 0:
                cmds.append('__msleep({sleep_amt:.2f});'.format(
                    sleep_amt=sleep_amt))
                pass
            edge_type = type(edge)

            ## handle each edge type
            if edge_type is CreateElementActionEdge:
                elemInstNum = edge.dst().instNum
                if elemInstNum in output_elements:
                    # if we're not interested in this element, then
                    # ignore this edge
                    cmds.append('add_elem({elemInstNum});'.format(
                        elemInstNum=elemInstNum))
                    pass
                pass

            elif edge_type is RenderUpdateSchedulingEdge:
                _write_render_update_sched_edge(edge, cmds, used_scopes)
                pass

            elif edge_type is SetResourceReferenceEdge:
                _write_set_resource_ref_edge(edge, cmds, output_elements, output_resources)
                pass

            elif edge_type is CreateDOMTimerEdge:
                timer = edge.dst()
                assert type(timer) is DOMTimer
                if timer.timerID in output_timers:
                    cmds.append('start_timer({timerID});'.format(timerID=timer.timerID))
                    pass
                pass

            elif edge_type is ClearDOMTimerEdge:
                timer = edge.dst()
                assert type(timer) is DOMTimer
                if timer.timerID in output_timers:
                    cmds.append('cancel_timer({timerID});'.format(timerID=timer.timerID))
                    pass
                pass

            elif edge_type is CreateXHREdge:
                xhr = edge.dst()
                assert type(xhr) is XMLHttpRequest
                if xhr.instNum in output_xhrs:
                    cmds.append('send_xhr({instNum});'.format(instNum=xhr.instNum))
                    pass
                pass

            elif edge_type is FetchSchedulingEdge:
                resInstNum = edge.dst().resInstNum()
                assert resInstNum > 0
                if resInstNum in output_resources:
                    cmds.append('fetch_res({instNum});'.format(instNum=resInstNum))
                    pass
                pass

            else:
                raise Exception('not reached')

            pass

        ####### done loop through out edges #####

        sleep_amt = scope.close_ts() - previous_ts
        assert sleep_amt >= 0
        if sleep_amt > 0:
            cmds.append('__msleep({sleep_amt:.2f});'.format(
                sleep_amt=sleep_amt))
            pass

        cmds.insert(0, '/* [{open_ts}, {close_ts}] scopeStart= {scopeStart} type= {scope_type} */'.format(
            open_ts=scope.open_ts(), close_ts=scope.close_ts(), scopeStart=scope.scopeStart(),
            scope_type=type(scope).__name__))
        angelscript_code_lines = list(map(lambda cmd: '  ' + cmd, cmds))

        output_scopes[scope_id] = angelscript_code_lines
        pass

    assert g_render_tree_update_scopes[0].is_initial()
    initial_render_tree_update_scope_id = g_render_tree_update_scopes[0].scope_id()
    if initial_render_tree_update_scope_id not in used_scopes:
        # the initial render update scope can be actually an inner
        # scope, e.g., the <body> element is actually inserted into
        # the document by a script, so the render update scope is part
        # of the script's run scope
        initial_render_tree_update_scope_id = 0
        pass

    page_model = {'resources': output_resources,
                  'elements': output_elements,
                  'xhrs': output_xhrs,
                  'exec_scopes': output_scopes,
                  'timers': output_timers,
                  'orig_used_hostnames': sorted(list(orig_used_hostnames)),
                  'initial_render_tree_update_scope_id': initial_render_tree_update_scope_id,
                  }

    main_doc_event_handling_scopes = [(eventName, scope_id) for (scope_id, eventName) \
                                      in main_doc_scope_id_to_event_name.items()]
    page_model['main_html'] = {
        'element_byte_offsets': sorted(main_html_elements),
        'event_handling_scopes': sorted(main_doc_event_handling_scopes),
        }

    with open(outfile, 'w') as fp:
        json.dump(page_model, fp, indent=2, sort_keys=True)
        pass

    pass

#############################################

def extract_model(logfile, *, outfile, show_timing=False, show_elem_end_byte_offset=False,
                  hide_edge_labels=False, group_peer_elems=False,
                  group_peer_fetches=False):
    from dot_drawing import DotDrawing
    DotDrawing.show_timing = show_timing
    DotDrawing.show_elem_end_byte_offset = show_elem_end_byte_offset
    DotDrawing.hide_edge_labels = hide_edge_labels

    openfunc = bz2.open if logfile.endswith('.bz2') else open
    with openfunc(logfile, 'rt') as fp:
        _extract_model(fp, outfile=outfile, group_peer_elems=group_peer_elems,
                       group_peer_fetches=group_peer_fetches)
        pass

    return

def _extract_model(infile, *, outfile, group_peer_elems=False, group_peer_fetches=False):
    g_log_processor.process(infile)

    ############################

    # sometimes we crop the log file to remove non-useful stuff at the
    # end, and in process we might remove a render tree update scope
    # for which we saw its being scheduled and thus created the
    # scheduling edge which still has None as the destination scope,
    # so assert this here so we can massage the log appropriately
    assert g_scheduled_render_tree_update is None

    ## are all the script scopes kosher?
    # ExecutionScope.check_non_overlapping(g_script_scopes)

    ExecutionScope.check_non_overlapping(g_render_tree_update_scopes)
    ExecutionScope.check_non_overlapping(g_load_pending_fonts_timer_scopes)


    ### output the model first
    _write_model(outfile)
    if True:
        return

    # currently we expect xmlhttprequest do not requests same urls as
    # elements
    assert len(set(g_url_to_elements.keys()).intersection(set(g_url_to_xhr.keys()))) == 0


    ### now can do the visualization if we want to


    ###
    ### this next block of code, besides informational printing, also
    ### matches up elements and fetches
    ###

    # list of elements that referred to fetched resources
    elements_with_fetches = []

    logging.info('Fetched resources:\n')
    
    sorted_by_start_times = sorted(filter(lambda res: res.type != ResourceType.MainResource,
                                          g_fetched_url_to_resource.values()),
                                   key=lambda res: res.initial_fetch_ts())
    for res in sorted_by_start_times:
        assert res.inc_req_count_by in (0, 1)
        initial_fetch_scope = res.initial_fetch_scope()

        elements = g_url_to_elements.get(res.url, None)
        if elements:
            elements_with_fetches.extend(elements)
            logging.info('  referenced by {numElems} elem(s):'.format(numElems=len(elements)))
            for elem in elements:
                ### important: link up the element to the resource. to
                ### do this in the webkit code, probably its the
                ### ResourceClient stuff (the element loader (e.g.,
                ### image loader) is a client of the resource)

                if initial_fetch_scope is None:
                    # fetch was started as part of the main html
                    inedges = list(elem.in_edges())
                    assert len(inedges) == 1
                    if type(inedges[0]) is ContainingEdge:
                        edgeClass = FetchSchedulingEdge
                        pass
                    elif type(inedges[0]) is CreateElementActionEdge and type(inedges[0].src()) is RunMicrotaskScope:
                        edgeClass = FetchMicrotaskSchedulingEdge
                        pass
                    else:
                        raise Exception('not reached')

                    edgeClass(src=elem, dst=res.initial_fetch(), ts=None)
                    pass
                else:
                    pass

                # ReferencingEdge(elem, res)

                logging.info('    * {}'.format(elem))
                if elem.creator_scope:
                    logging.info('        elem created during: {}'.format(elem.creator_scope))
                    pass
                pass
            pass
        else:
            # resource not referenced by any element, so it can be
            # things like css fonts, images, xhr, etc.
            assert res.creator_scope is not None

            xhr = g_url_to_xhr.get(res.url, None)
            if xhr:
                # make the xhr -- instead of the scope -- schedule the
                # resource fetch
                assert initial_fetch_scope is None
                inedges = list(res.in_edges())
                assert len(inedges) == 0, str(res.url)
                FetchSchedulingEdge(src=xhr, dst=res.initial_fetch(), ts=None)
                pass

            else:
                assert initial_fetch_scope is not None
                pass
            pass

        # print()

        # print('='*10)
        pass

    ##
    ## iteratively simplify things that are not too interesting, e.g.,
    ## fetch finish scopes that don't do anything interesting like run
    ## scripts or schedule resource fetches, dom timers that don't
    ## fire, or when fired dont do anything interesting, etc.
    ##
    ## this is mainly to make the drawn dependency graph easier to
    ## read.
    ##

    didsimplify = True
    while didsimplify:
        didsimplify = False

        for fetchreq in g_all_fetch_requests:
            didsimplify |= fetchreq.maybe_simplify_finish_scope()
            pass

        for domtimer in g_domTimers.values():
            didsimplify |= domtimer.maybe_simplify_timer_fired_scopes()
            didsimplify |= domtimer.maybe_simplify_entirely()
            pass

        for promise in g_promises.values():
            didsimplify |= promise.maybe_simplify_onSettle_microtask_scope()
            didsimplify |= promise.maybe_simplify_execute_scope()
            didsimplify |= promise.maybe_simplify_entirely()
            pass

        for xhr in g_xhrs.values():
            didsimplify |= xhr.maybe_simplify_entirely()
            pass

        for scope in g_render_tree_update_scopes:
            didsimplify |= scope.maybe_simplify_entirely()
            pass

        for scope in g_load_pending_fonts_timer_scopes:
            didsimplify |= scope.maybe_simplify_entirely()
            pass

        for scope in g_v8_scopes:
            didsimplify |= scope.maybe_simplify_entirely()
            pass

        elems = list(filter(lambda et: isinstance(et, Element), g_instNum_to_event_target.values()))
        for elem in elems:
            if type(elem) == ScriptElement:
                didsimplify |= elem.maybe_simplify_run_scope()
                pass
            result = elem.maybe_simplify_entirely()
            didsimplify |= result
            if result:
                del g_instNum_to_event_target[elem.instNum]
                pass
            pass
        pass

    dont_draw_elements = set()

    if group_peer_elems:
        # walk through all image and link elements and group them by
        # their parent, i.e., src of their "create" or "contain" edge

        # map from creator to set of elements
        groups = defaultdict(set)
        for elem in filter(lambda et: isinstance(et, (ImageElement, LinkElement)),
                            g_instNum_to_event_target.values()):
            assert len(elem.in_edges()) == 1
            edge = list(elem.in_edges())[0]
            parent = edge.src()
            assert edge not in groups[parent]
            groups[parent].add(edge)
            pass

        metainstnum = 100000
        for parent, orig_edges in groups.items():
            assert metainstnum not in g_instNum_to_event_target

            if len(orig_edges) < 2:
                # if only one one element in the group, then just
                # leave it be
                continue

            metaelem = MetaElement(instNum=metainstnum, creator_scope=None, create_ts=None)
            metaelem.label_mode = group_peer_elems
            metainstnum += 1

            # make the parent point to new metaelem
            MetaEdge(src=parent, dst=metaelem)

            # make the metaelem point to children. NOTE!!! that
            # multiple original image elements might reference the
            # same resource and thus schedule the same resource
            # fetch. since we're merging the original elements, we
            # need to take care to keep only one of the scheduling
            # edges, or dot_drawing will complain
            new_children = set()
            for edge in orig_edges:
                edge.drop() # drop edge from parent to original child

                child = edge.dst()
                assert isinstance(child, (ImageElement, LinkElement))
                dont_draw_elements.add(child)
                instNumsSet = metaelem.img_instNums if type(child) is ImageElement else metaelem.link_instNums
                instNumsSet.add(child.instNum)

                # update/drop original child's out edges
                for outedge in list(child.out_edges()):
                    if type(outedge) is ReferencingEdge:
                        outedge.drop()
                        pass
                    else:
                        new_child = outedge.dst()

                        # keep the edge only if we don't already point
                        # to the fetch, and that the fetch is
                        # interesting, i.e., it has some outedges
                        if (new_child not in new_children) and new_child.out_edges():
                            outedge.adopt_new_src(metaelem)
                            new_children.add(new_child)
                            pass
                        else:
                            outedge.drop()
                            pass
                        pass
                    pass
                pass
            pass
        pass

    if group_peer_fetches:
        # map from parent to set of edges that point to fetchreq's
        groups = defaultdict(set)
        for fetchreq in g_all_fetch_requests:
            assert type(fetchreq) is FetchRequest
            # we group only those with both no out edges and 1 in edge
            if (len(fetchreq.in_edges()) == 1) and (not fetchreq.out_edges()):
                edge = list(fetchreq.in_edges())[0]
                parent = edge.src()
                assert edge not in groups[parent]
                groups[parent].add(edge)
                pass
            pass

        class DummyObj(object):
            pass

        metainstnum = 200000
        for parent, orig_edges in groups.items():
            assert metainstnum not in g_fetched_instNum_to_resource

            if len(orig_edges) < 2:
                # if only one one element in the group, then just
                # leave it be
                continue

            metares = DummyObj()
            metares.instNum = metainstnum
            metares.type = ResourceType.Image # doesn't matter
            metafetch = MetaFetchRequest(metares, None, None, None, None, None)
            metafetch.label_mode = group_peer_fetches
            metainstnum += 1

            # make the parent point to meta obj
            MetaEdge(src=parent, dst=metafetch)

            # make the metafetch point to children
            for edge in orig_edges:
                edge.drop() # drop edge from parent to original child

                child = edge.dst()
                assert type(child) is FetchRequest
                metafetch.resInstNums.add(child.resInstNum())

                assert (not child.out_edges()) and (not child.in_edges())
                pass
            pass

        pass

    # #######
    # print('='*50)
    # print('Render tree update scopes:\n')
    # for scope in g_render_tree_update_scopes:
    #     outer_scopes_to_root = scope.outer_scopes_to_root()
    #     outer_scopes_to_root.reverse()
    #     print_scope_tree(outer_scopes_to_root)
    #     print()
    #     pass


    # #######
    # print('='*50)
    # print('V8 scopes:\n')
    # for scope in g_v8_scopes:
    #     outer_scopes_to_root = scope.outer_scopes_to_root()
    #     outer_scopes_to_root.reverse()
    #     print_scope_tree(outer_scopes_to_root)
    #     print()
    #     pass

    # #######
    # print('='*50)
    # print('Event handling scopes:\n')
    # for eventtarget in g_instNum_to_event_target.values():
    #     dom_event_handling_scopes = eventtarget.dom_event_handling_scopes
    #     if not dom_event_handling_scopes:
    #         continue

    #     print(str(eventtarget) + ' has these event handling scopes')
    #     for eventName, scopes in dom_event_handling_scopes.items():
    #         print('  event "{eventName}":'.format(eventName=eventName))
    #         for scope in scopes:
    #             print('     * {scope}'.format(scope=scope))
    #             pass
    #         pass
    #     print()
    #     pass


    # this shows only the abstract loading model of THIS particular
    # page load as expressed in the log. for example, if all external
    # scripts were instantaneously available (e.g., cached) while the
    # main html downloads very slowly, then the number of resources
    # that are loaded by the preloadscanner will be very small
    with open('page_load.dot', 'w') as dot_output_file:
        dot_output_file.write('''
strict digraph pagemodel {
    # graph[size="7.75,10.25"];
    fontsize = 12;
    compound = true;
''')

        scope_verbosity = DotDrawingEntity.ScopeVerbosity.NORMAL
        indentAmount = 4

        nodes_specs = {}
        edges_specs = {}

        ####
        ####
        #### draw the global scopes
        ####
        ####

        for scope in g_top_level_scopes:
            scope.draw_is_visited() or scope.draw(
                nodes_specs=nodes_specs, edges_specs=edges_specs,
                indentAmount=indentAmount, scope_verbosity=scope_verbosity)
            pass

        # also render tree update scopes
        for scope in g_render_tree_update_scopes:
            scope.draw_is_visited() or scope.draw(
                nodes_specs=nodes_specs, edges_specs=edges_specs,
                indentAmount=indentAmount, scope_verbosity=scope_verbosity)
            pass

        ####
        ####
        #### draw all the fetched resources
        ####
        ####

        for res in sorted(filter(lambda res: (res.type != ResourceType.MainResource) and len(res.in_edges()) > 0,
                                 g_fetched_instNum_to_resource.values()),
                          key=lambda res: res.initial_fetch_ts()):
            res.draw_is_visited() or res.draw(nodes_specs=nodes_specs, edges_specs=edges_specs,
                indentAmount=indentAmount+4, scope_verbosity=scope_verbosity)
            pass

        ####
        ####
        #### draw the elements that refer to fetched resources. sort
        #### elements by order appearing in html
        ####
        ####

        assert not g_main_doc.draw_is_visited()
        g_main_doc.draw(nodes_specs=nodes_specs, edges_specs=edges_specs,
                        indentAmount=indentAmount+4, scope_verbosity=scope_verbosity)

        # # for element in sorted(elements_with_fetches, key=lambda elem: elem.create_ts):
        # for element in [e for e in elements_with_fetches if e not in dont_draw_elements]:
        #     assert element.resource() is not None, str(element)
        #     element.draw_is_visited() or element.draw(
        #         nodes_specs=nodes_specs, edges_specs=edges_specs,
        #         indentAmount=indentAmount+4, scope_verbosity=scope_verbosity)
        #     pass

        _output_legend(dot_output_file)

        _output_nodes(dot_output_file, nodes_specs, indentAmount=indentAmount, do_group_by_attrs=True)

        for scope_subgraph_spec in ExecutionScope._scope_subgraph_specs.values():
            _output_a_subgraph(dot_output_file, scope_subgraph_spec, indentAmount)
            pass
        ExecutionScope._scope_subgraph_specs.clear()

        _output_edges(dot_output_file, edges_specs, indentAmount=indentAmount)

        dot_output_file.write('''
''')

        dot_output_file.write('} # close graph\n')

        pass
    return

def _output_legend(fileobj):
    fileobj.write('subgraph cluster_legend {\n')
    fileobj.write('    label="Legend";\n')

    # create dummy dot drawing entities that we can grab their drawing
    # properties to create a legend
    entities = []
    for restype, shortname in resource_type_short_names.items():
        res = Resource(instNum=-1, url=None, type_=restype,
                       isDataURL=True, create_ts=-1, creator_scope=None)
        entities.append((shortname, res))
        pass

    entities.append(('promise', Promise(instNum=-1, create_ts=-1, creator_scope=None)))
    entities.append(('xhr', XMLHttpRequest(instNum=-1, create_ts=-1, creator_scope=None)))

    class _DummyScope(UnimportantExecutionScope):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            pass
        def draw_get_fillcolor(self):
            return 'lightgrey'
        def draw_get_style(self):
            return 'filled'
        def draw_get_shape(self):
            return 'box'
        pass

    dummyscope = _DummyScope(-1, -1, None)
    entities.append(('DOM timer', DOMTimer(-1, -1, singleShot=True,
                                           creator_scope=dummyscope, create_ts=-1)))

    entities.append(('an exec scope', _DummyScope(-1, -1, None)))

    for label, entity in entities:
        attrs_str = ', '.join(
                ['{}="{}"'.format(k, v) for k, v in (('color', entity.draw_get_color()),
                                                     ('fillcolor', entity.draw_get_fillcolor()),
                                                     ('shape', entity.draw_get_shape()),
                                                     ('style', entity.draw_get_style()),
                                                     ('label', label),
                                                     ) if v])
        fileobj.write('   "{nodename}" [{attrs_str}];\n'.format(nodename=label, attrs_str=attrs_str))
        del entity
        pass

    entities.clear()

    fileobj.write('}\n')
    pass

def _output_nodes(fileobj, nodes_specs, indentAmount, do_group_by_attrs=False):
    if do_group_by_attrs:
        # group nodes by the attrs, i.e., nodes with same
        # attrs should be grouped into the same subgraph
        common_attrs = set(['style', 'color', 'shape', 'fillcolor'])
        node_groups = defaultdict(set)
        for nodename, node_spec in nodes_specs.items():
            attrs = node_spec['attrs']
            assert nodename == node_spec['name']
            attrs_str = ', '.join(
                ['{}="{}"'.format(k, v) for k, v in sorted(attrs.items()) if k in common_attrs and v])
            if attrs_str in node_groups:
                assert nodename not in node_groups[attrs_str]
                pass
            node_groups[attrs_str].add(nodename)
            pass

        for i, common_attrs_str in enumerate(sorted(node_groups.keys())):
            fileobj.write(
                (indentAmount + (0*4))*' ' + 'subgraph node_group_{i}_ {{\n'.format(i=i))
            fileobj.write(
                (indentAmount + (1*4))*' ' + 'node [{common_attrs_str}];\n'.format(common_attrs_str=common_attrs_str))
            for nodename in sorted(node_groups[common_attrs_str]):
                node_attrs_str = ', '.join(
                    ['{}="{}"'.format(k, v) for k, v in sorted(nodes_specs[nodename]['attrs'].items()) if k not in common_attrs and v])
                fileobj.write(
                    (indentAmount + (1*4))*' ' + '{name} [{node_attrs_str}];\n'.format(
                        name=nodename, node_attrs_str=node_attrs_str))
                pass
            fileobj.write(
                (indentAmount + (0*4))*' ' + '}}\n'.format(i=i))
            pass
        pass
    else:
        for nodename, node_spec in sorted(nodes_specs.items()):
            attrs = node_spec.get('attrs', None)
            if attrs is None:
                attrs = {}
                pass
            node_attrs_str = ', '.join(
                ['{}="{}"'.format(k, v) for k, v in sorted(attrs.items()) if v])
            fileobj.write(
                (indentAmount + (0*4))*' ' + '{name} [{node_attrs_str}];\n'.format(
                    name=nodename, node_attrs_str=node_attrs_str))
            pass
        pass

    return

def _output_a_subgraph(fileobj, spec, indentAmount):
    do_draw_self = (spec['name'] is not None)
    if do_draw_self:
        fileobj.write((indentAmount + (0*4))*' ' + 'subgraph {name} {{\n'.format(name=spec['name']))
        if 'comment' in spec:
            fileobj.write((indentAmount + (1*4))*' ' + '# {comment}\n'.format(comment=spec['comment']))
            pass
        attrs = spec['attrs']
        attrs_str = ', '.join(
            ['{}="{}"'.format(k, v) for k, v in sorted(attrs.items()) if v])
        fileobj.write((indentAmount + (1*4))*' ' + 'graph [{attrs_str}];\n'.format(attrs_str=attrs_str))
        _output_nodes(fileobj, spec['nodes'], indentAmount+4)
        pass
    for subgraph_spec in spec['subgraphs']:
        _output_a_subgraph(fileobj, subgraph_spec, indentAmount + (4 if do_draw_self else 0))
        pass
    if do_draw_self:
        fileobj.write((indentAmount + (0*4))*' ' + '}} # close subgraph {name}\n'.format(name=spec['name']))
        pass
    return

def _output_edges(fileobj, edges_specs, indentAmount):

    # group edges by the attrs, i.e., edges with same attrs should
    # be grouped into the same subgraph
    common_attrs = set(['style', 'color', 'shape'])

    edge_groups = defaultdict(set)
    for (src, dst, edge_id), edge_spec in edges_specs.items():
        attrs = edge_spec.get('attrs', None)
        if attrs is None:
            attrs = {}
            pass
        attrs_str = ', '.join(
            ['{}="{}"'.format(k, v) for k, v in sorted(attrs.items()) if k in common_attrs and v])
        if attrs_str in edge_groups:
            assert (src, dst) not in edge_groups[attrs_str]
            pass
        edge_groups[attrs_str].add((src, dst, edge_id))
        pass

    for i, common_attrs_str in enumerate(sorted(edge_groups.keys())):
        fileobj.write(
            (indentAmount * 1)*' ' + 'subgraph edge_group_{i}_ {{\n'.format(i=i))
        fileobj.write(
            (indentAmount * 2)*' ' + 'edge [{common_attrs_str}];\n'.format(common_attrs_str=common_attrs_str))
        for src, dst, edge_id in sorted(edge_groups[common_attrs_str]):
            edge_attrs = edges_specs[(src, dst, edge_id)].get('attrs', None)
            if edge_attrs is None:
                edge_attrs = {}
                pass
            edge_attrs_str = ', '.join(
                ['{}="{}"'.format(k, v) for k, v in sorted(edge_attrs.items()) if k not in common_attrs and v])
            fileobj.write(
                (indentAmount * 2)*' ' + '{src} -> {dst} [{edge_attrs_str}];\n'.format(
                    src=src, dst=dst, edge_attrs_str=edge_attrs_str))
            pass
        fileobj.write(
            (indentAmount * 1)*' ' + '}}\n'.format(i=i))
        pass
    return
